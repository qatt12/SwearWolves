#                                  `.-::/+osyyyyso//:.`
#                               .-/oyyyyyysssyyhhhyhsoo:
#                             .:/oyyyssooossysooosymhddys:
#                            -::sysooooossooooooooh:ysyhhy+
#                           :--syooooossoooooooooy/ .soyyhs+
#                          ---ssoooossooooooooooy/.-:/yoyhyy/
#                          :--+oooooooysooooooyo.  `` -ssohso.
#                          ..::oooooshsoooosy+.        :hohoy.
#                        :/-/+/soooohoosshy+-`          yshoo-
#                         +:s+s+yyohssyyy:://:`      -+/ydsoo`
#                          /:://:o/dssosyddhoym`    ohydoh:o-
#                          `./-:-.osoos/-sds..+  `-/dssoy/..
#                            .so/-soooy`...```  `:-+:`+so.
#                         `.oyods+hooos        `/::::`/oo
#                     `:+ossssyos+ssoso     .```.:--..++y`
#                  `:+ssssoos/:::/ososy/:-`  `   ` .:-`+o+
#                `/oosysooooo+-`:+ysooho+//:-```.:/:.  `ss:
#               -oooyyooooys-///-.-+s+y:+o+o.://o:-:::-.`oy/
#              :oooysooosyssooyoso:--++:.-/+oo+++---:+:/` /y+`
#             ./ooysoosyysys//:/:/://-/+-----:----/sys/.`.`:s/.`
#             -ooyyooshssdyhhyy+//:--:://:::::::::/ssoy..`.`+.
#             /oohooyyosmdNm:....--+ooo:-:///:://...sss/o/.--
#             ooyyoyyoomhyN+       ```:o::---....---.+sooo/+s
#            `/ohoshooddosm-`       ```-o-`...`.-.`  ``.:oyshy+-
#            `:ohohoosmsohd..       `-/.o++`    `.--.`   `-o:ssys:
#             :+hohoohdooyh:``       `:++/os+:-`  `.-::.   /y/oydds.
#             -:yyyoodhsoshh`/``      `++://oso++:.``--::  :h++ohhod-
#              :/hhoodshooyd/o-`       `+::::/+++oss+:.--: oo+++od:+d`.`
#              `:+hsodohsooh+hh-`     .`.o//:/++++++ooo+:+:y++++:d/-d:.`
#               `:+ssdosdsossomy+:`   :.`:y+:/++++++++++syso++++od++s .
#                 -/oyyoshyoo+y+yo:`  `:-`/y/:/++++++++ohdsoshyhys+-/
#                  `:shysoyhsss//do/-   .:-ss+:/+oooosossm+/sys/`   `
#                     .ohy+shdd:`:ho::`   `.ssso+sssssooom``oo
#                       `:/soyN-  ys+-:`    `+.o+oooo+++sy``oo
#                         `oysm/  o/yd:`     `++s+++++++Ns``os
#                          `oyyh  sh+dmy-     .+sy+++++yN+:`os
#                         ` `+oy `m//+ydms.    -/ys+++ohm+-:oo`
#                        `` `h+/`yd.o:+sohdo. ``:-ho+ohsmy`.s/:
#                         ` os.:ym/o///+s-oNh/`   :dohoyhh:`o-s````````````...:/++//:////:::-..`
#                        ``/o`:hNd:::://os-/hh/`   /yyy+yhy`+-y::://////::/+/////+++oys+////::--:.
#                -        .s`+hNNs/////+/oy:-+`    `odo+ysh.//y-----:::-----/oo+//:://:/+++:--:/--/`
#                :       `s..yddy/:::::///+ho:+``...:mhyyhy//ss////o///::---:::/+ssoo/+sos/+s+.`:+-+
#                ``      o.`yhys//////////++dyyyoo++/::/-:o``+`   ````........``  `.-//::/so+yh/``so`
#                       o- +syd+////o/+oo+o+/soss.     ```s  +    `           ````    `-:`-y:/yh+`/d`
#                      +: +.om++/+++s+/-..  :///`        `o  /`   `              ``     `/.:+-.h+/:m
#                     +: /--d/:+++:.-      `o:o           -  .`                          `+//- ssoo/
#                    +- ./ ss`.-.`         :+/+`                         ``               .y.-.hss+
#                  `o/  o `N/-`            :o+/:::.                  ``.-.`   ``         .+s-:hmm+
#                  o/: -/ -d.```           .y+///.               -::::+s+.``..``       .+++o/hd+-
#                 ./+  o  oo                oo+o:``             `..-sdo::/+/.-/.`   `.:so++-yy-
#                   +  o  h/                `y++/--.             `/dhs+/+//::/-.. `/oho/o-::y.
#                  .:  o  y+                 -so+/+         ``.:/hmo+--/--:--o/. `/oy/sho/` :`
#                  --  o  oo`          `      .os/+/.```..://::-ho/--/--/--:/s..-/hs/yhs+`    ``..``
#                `.::``-/ o.s`                 `-+sossoo/:.``..sh-+--/:-/:-:/--:yhoooo--..--.``   `...
#         ``--....``+--.o:o`-o:``         ```.-////s-...-:://:ooy::+--/--+---:ooso+o-.       `.....`
#    ``--...``---....`   +-   .:/+//::::::::::.```.s+oo+::-.``do:/-:/--/:-//+oos++: `````          ```
# .--.. `.-:-:...`        :/.`   `..---..-:----:so+s/...`    /yo-::--/--:/+ssy+o:   ````.----...```
# `  `---.       `...---``  -:::.````` ``...--..``` +        hs/--:---::/osy+oo-.-......` .``
# `-..                  ..----``.-----.....``     ``-/-----.:d/-/---:-:syysoo.`          .  `  ``
# ```                         .----.`       `.:://+//+o:--..+o---:---oyyooo-  -          -  `  .     -
#  ``..`                            ....-:/++//+o:::.``+:::/h---:--/ss//o//  :`         -`  ` .`    `:
#      `..--.            `       ``.-+ooo/+:--` :  `-:oy++s/h-:--:+oo-:y+`/  +          /   ` :     /
#           `.----` ```..````````-+s+::---.    .- .yos//.:o:s--:+y+:++/:o/` --          /   ``-    -.
# `               .--:-`      .//:`---   -`    :. -s/.-:/-/y+-:/ss--ss--h/  +          `:   `:     /
# `..`                 .-.--+s/``--`     /     /  `s:----/:o:/::-y--+s-:y   +          -.   `:    `:
#    `...`               -/s/..+.        /     /   .o/::--+//::--h-+:s.s:  `+          /    .-    :`
#        `....         -/-+` ..:        `/     /    `/s-:o/:--::+y-o+/.h+  -:          /    :     :
#             ..-.   `+- +` . .-        --     /     `y/-o--:+:-yo//s-o:+  :.          /    :     -
#       ```````  `..-+   . `` /`        +      /     -o:-+---+..d:o:s+//.  /.          /   `-     .
#              ````-+         +         o      /     .s-.o---o-/yo:+++s/   /.          /   ..     .
#                  o          +         o      /     `o-.o---o-/hossdNd    :.          /          `

# blocks are, as stated in spriteling.py, intended to be placed and then never moved. With the notable exception
# of floors, blocks are also supposed to impede movement

import spriteling, pygame, config, events
from events import event_maker

wall_size = 65
corner_size = 65

# class for stationary objects that are placed and then never moved.
class block(spriteling.spriteling):
    def __init__(self, img, loc, **kwargs):
        super().__init__(image=img, loc=loc, **kwargs)
        # if the block is rooted, it is attached to a fixed location; an (x, y) tuple
        self.rooted = None

        # if this block is linked, then it is attached to another spriteling, and thus positions its own rect relative
        # to where its link is
        self.link = None
        # the link direction. the first int is how far to the left (negative) or right (positive) of its
        # link this block is, and the second is how far above (negative) or below (positive)
        # (0,0) means that this block's center will always be matched to its link's center, and a +/-1 in either field
        # indicates that this block is attached to the inner side/edge of its link. +/-2 indicates an attachment
        # to the outer edge
        self.link_dir = (0, 0)

    # roots the block in place
    def place(self, root_loc):
        self.rooted = root_loc

    # attaches/links the block to another
    def attach(self, link, dir):
        self.link = link
        self.link_dir = dir

    # the update method simply returns them to their designated positions
    # DEBUG: at least it should. currently it does fuck all. Not sure why
    def update(self, *args):
        #print("block update")
        if self.rooted is not None:
            self.rect.center = self.rooted
        elif self.link is not None:
            x, y = self.link_dir[0], self.link_dir[1]
            if x == 0 and y == 0:
                self.rect.center = self.link.rect.center
            else:
                if x == 2:
                    self.rect.right = self.link.rect.left
                elif x == 1:
                    self.rect.left = self.link.rect.left
                elif x == 0:
                    self.rect.centerx = self.link.rect.centerx
                elif x == -1:
                    self.rect.right = self.link.rect.right
                elif x == -2:
                    self.rect.left = self.link.rect.right

                if y == 2:
                    self.rect.top = self.link.rect.bottom
                elif y == 1:
                    self.rect.bottom = self.link.rect.bottom
                elif y == 0:
                    self.rect.centery = self.link.rect.centery
                elif y == -1:
                    self.rect.top = self.link.rect.top
                elif y == -2:
                    self.rect.bottom = self.link.rect.top

    # adjust allows you to dictate/move the side of door's rect to match a given line/value. Intended to be used within
    # room to properly line the door up with the walls
    def adjust(self, **kwargs):
        if 'left' in kwargs:
            self.rect.left = kwargs['left']
        if 'right' in kwargs:
            self.rect.right = kwargs['right']
        if 'top' in kwargs:
            self.rect.top = kwargs['top']
        if 'bottom' in kwargs:
            self.rect.bottom = kwargs['bottom']
        if 'bound_rect' in kwargs:
            #if self.rect.top < kwargs['bound_rect'].top:
            #    self.rect.top = kwargs['bound_rect'].top
            #elif self.rect.bottom > kwargs['bound_rect'].bottom:
            #    self.rect.bottom = kwargs['bound_rect'].bottom
            #if self.rect.right > kwargs['bound_rect'].right:
            #    self.rect.right = kwargs['bound_rect'].right
            #elif self.rect.left < kwargs['bound_rect'].left:
            #    self.rect.left = kwargs['bound_rect'].left
            self.rect.clamp_ip(kwargs['bound_rect'])
        self.hitbox.rect.clamp_ip(self.rect)


# Straight up copy-pasted this stuff from my earlier project. it should work in here with limited modifications
class wall(block):
    wall_size = 65
    def __init__(self, facing, *args):
        super(wall, self).__init__(*args)
        self.layer = config.outer_wall_layer
        self.facing = facing
        if facing == 'down':
            self.hitbox = spriteling.hitbox(self,
                                            scale_y=-wall.wall_size, bottom_side=self.rect.bottom)
        elif facing == 'up':
            self.hitbox = spriteling.hitbox(self,
                                            scale_y=-wall.wall_size, top_side=self.rect.top)
        elif facing == 'left':
            self.hitbox = spriteling.hitbox(self,
                                            scale_x=-wall.wall_size, left_side=self.rect.left)
        elif facing == 'right':
            self.hitbox = spriteling.hitbox(self,
                                            scale_x=-wall.wall_size, right_side=self.rect.right)
        #self.hitboxes.add(self.hitbox)


class inner_wall(wall):
    def __init__(self):
        pass


# this is for inward facing/concave corners. the orientation is specified manually by string. Not exactly elegant,
# fancy, or portable, but since there are at most four cases (and this is only ever called in room.py::class::theme),
# hardcoded constants will work
class corner(block):
    corner_size = 65
    def __init__(self, facing, *args):
        super().__init__(*args)
        self.layer = config.outer_wall_layer
        if facing == 'top_left':
            self.hitbox = (spriteling.hitbox(self,
                                             scale_x=-corner.corner_size, scale_y=-corner.corner_size,
                                             top_side=self.rect.top, left_side=self.rect.left))
        elif facing == 'top_right':
            self.hitbox = (spriteling.hitbox(self,
                                             scale_x=-corner.corner_size, scale_y=-corner.corner_size,
                                             top_side=self.rect.top, right_side=self.rect.right))
        elif facing == 'bottom_right':
            self.hitbox = (spriteling.hitbox(self,
                                             scale_x=-corner.corner_size, scale_y=-corner.corner_size,
                                             bottom_side=self.rect.bottom, right_side=self.rect.right))
        elif facing == 'bottom_left':
            self.hitbox = (spriteling.hitbox(self,
                                             scale_x=-corner.corner_size, scale_y=-corner.corner_size,
                                             bottom_side=self.rect.bottom, left_side=self.rect.left))


# the floor sprite is bit tricky, as it creates a rectangular floor of the size specified and sets it as its image
# this is intended to be treated as the main image/surface of a/the room
class floor(block):
    def __init__(self, size, theme, *args):
        # passes dummy params to the parent class
        super().__init__(theme.image_lookup['f'], (0, 0))
        size_x, size_y = size[0], size[1]
        self.image = pygame.Surface((size_x * config.tile_scalar, size_y * config.tile_scalar))

        self.layer = config.floor_layer

        # basic loop to blit all the floor tiles into one surface
        for y in range(0, size_y+1):
            for x in range(0, size_x+1):
                self.image.blit(theme.image_lookup['f'], (x * config.tile_scalar, y * config.tile_scalar))
        self.rect = self.image.get_rect()

        print(self.rect)


# DO NOT INCLUDE A KEYWORDED HITBOX IN THE INSTANTIATION OF A TRIGGER
class trigger(block):
    def __init__(self, img, loc, outer_box, **kwargs):
        try:
            assert ('hitbox' not in kwargs), 'DO NOT INCLUDE A KEYWORDED HITBOX IN THE INSTANTIATION OF A TRIGGER'
        except AssertionError:
            # include a new_event here
            print(AssertionError)
            #not sure how to avoid sending two hitbox kwargs up to spriteling
        super().__init__(img, loc, hitbox=outer_box, **kwargs)

        self.layer = config.door_layer   # by default, triggers are in the floor cosmetics layer

class contact_trigger(trigger):
    def __init__(self, img, loc, outer_box, **kwargs):
        super().__init__(img, loc, outer_box, **kwargs)

    def check_collide(self, target):
        pass

# interact triggers have a callback function that is passed into them at init. this function looks for one or more
# traits/activities and if they should/shouldn't be happening, and returns True if everything matches up
class interact_trigger(trigger):
    def __init__(self, img, loc, outer_box, look_for, timer, **kwargs):
        super().__init__(img, loc, outer_box, **kwargs)
        self.look_for = look_for
        self.timer = timer * config.fps
        self.tick = 0

    def __call__(self, *args, **kwargs):
        self.tick += self.look_for(*args, **kwargs)
        if self.tick >= self.timer:
            event_maker.make_entry('trace', 'interaction trigger has worked', '', 'blocks')

# a screen/filter function that assesses whether or not a spriteling is undertaking a particular activity.
# this is intended to be a template form of the look_for method, which is going to be used as the trigger part of a
# triggered spriteling
def look_for_activity(*args, **kwargs):
    try:
        assert (isinstance(args[0], spriteling.spriteling)), "ERROR: the first arg should be a spriteling"
        if len(args) > 1:
            assert (isinstance(args[1], int)), "ERROR: need a trip value"
    except AssertionError:
        event_maker.make_entry('error', str(AssertionError), "perhaps you meant to call a different look_for?", 'blocks')
        return False
    if 'must_be' in kwargs:
        for each in kwargs['must_be']:
            if each in args[0].activity_state and args[0].activity_state[each]:
                pass
            else:
                return False
    else:
        return False
    if 'must_not_be' in kwargs:
        try:
            assert (not (any in kwargs['must_be'] in kwargs["must_not_be"])), "ERROR: mutually exclusive must (not) be"
        except AssertionError:
            event_maker.make_entry('error', 'assertion', (str(AssertionError) + "double-check your must/must_not_be"), 'blocks', True, True,
                                   'block', 'blocks', 'basic',
                                   loc_src='blocks.look_for_activity', must_be=kwargs['must_be'], must_not_be=kwargs['must_not_be'])
            return False
        for each in kwargs['must_not_be']:
            if each in args[0].activity_state and args[0].activity_state[each]:
                return False
    return True


class door(interact_trigger):
    def __init__(self, door_type=events.next_room, **kwargs):
        # DEBUG STUFF at least the image is. UNTIL YOTOLL DRAWS A DOOR
        pass_img = pygame.transform.scale(pygame.image.load('Animation\img_door.png').convert_alpha(), (config.tile_scalar, config.tile_scalar))
        event_maker.make_entry('error', 'DEBUG', "placeholder image", 'blocks', True, True)
        pass_loc = (0, 0)
        pass_rect = pass_img.get_rect()
        pass_trig = look_for_activity
        pass_timer = 1
        super().__init__(pass_img, pass_loc, pass_rect, pass_trig, pass_timer)
        # the kwargs are for positioning, as well as giving it a root at init (see class:blocks for what this means)
        # DEBUG: I am unsure of why, but the positioning for doors is slightly off for doors located on the right or
        # left walls: they are shifted off-centery by about 50 pixels. The practical impact of this is minimal
        if 'coords' in kwargs:
            self.rect.center = kwargs['coords']
        if 'root_wall' in kwargs:
            self.rect.center = kwargs['root_wall'].rect.center
        if 'side_x' in kwargs:
            self.rect.centerx = kwargs['side_x']
            self.rect.centery = (config.tile_scalar + (kwargs['pos']*config.tile_scalar)) + kwargs['bound_y']
        if 'side_y' in kwargs:
            self.rect.centery = kwargs['side_y']
            self.rect.centerx = (config.tile_scalar + (kwargs['pos']*config.tile_scalar)) + kwargs['bound_x']
        self.door_type = door_type
        self.hitbox.update()
        self.layer = config.door_layer

    # simple, placeholder-y method that moves the player on top of the door. Will prbly be rewritten with more complex
    # behavior (that doesn't stack all the players on top of each other)
    def enter(self, player):
        player.rect.center = self.rect.center

    def __call__(self, target):
        if self.look_for(target, must_be=['interacting']):
            self.tick += 1
        else:
            self.tick = 0
        if self.tick >= self.timer:
            event_maker.make_entry('log', 'door interact', "door is receiving full player interaction", 'blocks', True, False, obj_src=self, loc_src='door')
            event_maker.new_event(events.room_event, file_src='blocks', subtype=self.door_type)


class ledge(block):
    def __init__(self, loc, dir):
        # DEBUUG: YOTOLL has some image integration to do
        pass_img = pygame.transform.scale(pygame.image.load('misc\spirit.jpg').convert_alpha(), (config.tile_scalar, config.tile_scalar))
        # expand this to permit all four directions a ledge can face
        if dir == 'up':
            pygame.transform.rotate(pass_img, 90)
        super().__init__(pass_img, loc)

        self.layer = config.floor_cos
