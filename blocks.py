#                                  `.-::/+osyyyyso//:.`
#                               .-/oyyyyyysssyyhhhyhsoo:
#                             .:/oyyyssooossysooosymhddys:
#                            -::sysooooossooooooooh:ysyhhy+
#                           :--syooooossoooooooooy/ .soyyhs+
#                          ---ssoooossooooooooooy/.-:/yoyhyy/
#                          :--+oooooooysooooooyo.  `` -ssohso.
#                          ..::oooooshsoooosy+.        :hohoy.
#                        :/-/+/soooohoosshy+-`          yshoo-
#                         +:s+s+yyohssyyy:://:`      -+/ydsoo`
#                          /:://:o/dssosyddhoym`    ohydoh:o-
#                          `./-:-.osoos/-sds..+  `-/dssoy/..
#                            .so/-soooy`...```  `:-+:`+so.
#                         `.oyods+hooos        `/::::`/oo
#                     `:+ossssyos+ssoso     .```.:--..++y`
#                  `:+ssssoos/:::/ososy/:-`  `   ` .:-`+o+
#                `/oosysooooo+-`:+ysooho+//:-```.:/:.  `ss:
#               -oooyyooooys-///-.-+s+y:+o+o.://o:-:::-.`oy/
#              :oooysooosyssooyoso:--++:.-/+oo+++---:+:/` /y+`
#             ./ooysoosyysys//:/:/://-/+-----:----/sys/.`.`:s/.`
#             -ooyyooshssdyhhyy+//:--:://:::::::::/ssoy..`.`+.
#             /oohooyyosmdNm:....--+ooo:-:///:://...sss/o/.--
#             ooyyoyyoomhyN+       ```:o::---....---.+sooo/+s
#            `/ohoshooddosm-`       ```-o-`...`.-.`  ``.:oyshy+-
#            `:ohohoosmsohd..       `-/.o++`    `.--.`   `-o:ssys:
#             :+hohoohdooyh:``       `:++/os+:-`  `.-::.   /y/oydds.
#             -:yyyoodhsoshh`/``      `++://oso++:.``--::  :h++ohhod-
#              :/hhoodshooyd/o-`       `+::::/+++oss+:.--: oo+++od:+d`.`
#              `:+hsodohsooh+hh-`     .`.o//:/++++++ooo+:+:y++++:d/-d:.`
#               `:+ssdosdsossomy+:`   :.`:y+:/++++++++++syso++++od++s .
#                 -/oyyoshyoo+y+yo:`  `:-`/y/:/++++++++ohdsoshyhys+-/
#                  `:shysoyhsss//do/-   .:-ss+:/+oooosossm+/sys/`   `
#                     .ohy+shdd:`:ho::`   `.ssso+sssssooom``oo
#                       `:/soyN-  ys+-:`    `+.o+oooo+++sy``oo
#                         `oysm/  o/yd:`     `++s+++++++Ns``os
#                          `oyyh  sh+dmy-     .+sy+++++yN+:`os
#                         ` `+oy `m//+ydms.    -/ys+++ohm+-:oo`
#                        `` `h+/`yd.o:+sohdo. ``:-ho+ohsmy`.s/:
#                         ` os.:ym/o///+s-oNh/`   :dohoyhh:`o-s````````````...:/++//:////:::-..`
#                        ``/o`:hNd:::://os-/hh/`   /yyy+yhy`+-y::://////::/+/////+++oys+////::--:.
#                -        .s`+hNNs/////+/oy:-+`    `odo+ysh.//y-----:::-----/oo+//:://:/+++:--:/--/`
#                :       `s..yddy/:::::///+ho:+``...:mhyyhy//ss////o///::---:::/+ssoo/+sos/+s+.`:+-+
#                ``      o.`yhys//////////++dyyyoo++/::/-:o``+`   ````........``  `.-//::/so+yh/``so`
#                       o- +syd+////o/+oo+o+/soss.     ```s  +    `           ````    `-:`-y:/yh+`/d`
#                      +: +.om++/+++s+/-..  :///`        `o  /`   `              ``     `/.:+-.h+/:m
#                     +: /--d/:+++:.-      `o:o           -  .`                          `+//- ssoo/
#                    +- ./ ss`.-.`         :+/+`                         ``               .y.-.hss+
#                  `o/  o `N/-`            :o+/:::.                  ``.-.`   ``         .+s-:hmm+
#                  o/: -/ -d.```           .y+///.               -::::+s+.``..``       .+++o/hd+-
#                 ./+  o  oo                oo+o:``             `..-sdo::/+/.-/.`   `.:so++-yy-
#                   +  o  h/                `y++/--.             `/dhs+/+//::/-.. `/oho/o-::y.
#                  .:  o  y+                 -so+/+         ``.:/hmo+--/--:--o/. `/oy/sho/` :`
#                  --  o  oo`          `      .os/+/.```..://::-ho/--/--/--:/s..-/hs/yhs+`    ``..``
#                `.::``-/ o.s`                 `-+sossoo/:.``..sh-+--/:-/:-:/--:yhoooo--..--.``   `...
#         ``--....``+--.o:o`-o:``         ```.-////s-...-:://:ooy::+--/--+---:ooso+o-.       `.....`
#    ``--...``---....`   +-   .:/+//::::::::::.```.s+oo+::-.``do:/-:/--/:-//+oos++: `````          ```
# .--.. `.-:-:...`        :/.`   `..---..-:----:so+s/...`    /yo-::--/--:/+ssy+o:   ````.----...```
# `  `---.       `...---``  -:::.````` ``...--..``` +        hs/--:---::/osy+oo-.-......` .``
# `-..                  ..----``.-----.....``     ``-/-----.:d/-/---:-:syysoo.`          .  `  ``
# ```                         .----.`       `.:://+//+o:--..+o---:---oyyooo-  -          -  `  .     -
#  ``..`                            ....-:/++//+o:::.``+:::/h---:--/ss//o//  :`         -`  ` .`    `:
#      `..--.            `       ``.-+ooo/+:--` :  `-:oy++s/h-:--:+oo-:y+`/  +          /   ` :     /
#           `.----` ```..````````-+s+::---.    .- .yos//.:o:s--:+y+:++/:o/` --          /   ``-    -.
# `               .--:-`      .//:`---   -`    :. -s/.-:/-/y+-:/ss--ss--h/  +          `:   `:     /
# `..`                 .-.--+s/``--`     /     /  `s:----/:o:/::-y--+s-:y   +          -.   `:    `:
#    `...`               -/s/..+.        /     /   .o/::--+//::--h-+:s.s:  `+          /    .-    :`
#        `....         -/-+` ..:        `/     /    `/s-:o/:--::+y-o+/.h+  -:          /    :     :
#             ..-.   `+- +` . .-        --     /     `y/-o--:+:-yo//s-o:+  :.          /    :     -
#       ```````  `..-+   . `` /`        +      /     -o:-+---+..d:o:s+//.  /.          /   `-     .
#              ````-+         +         o      /     .s-.o---o-/yo:+++s/   /.          /   ..     .
#                  o          +         o      /     `o-.o---o-/hossdNd    :.          /          `

# blocks are, as stated in spriteling.py, intended to be placed and then never moved. With the notable exception
# of floors, blocks are also supposed to impede movement

import spriteling, pygame, config

wall_size = 65
corner_size = 50

# class for stationary objects that are placed and then never moved.
class block(spriteling.spriteling):
    def __init__(self, img, loc, **kwargs):
        super().__init__(image=img, loc=loc, **kwargs)
        # if the block is rooted, it is attached to a fixed location; an (x, y) tuple
        self.rooted = None

        # if this block is linked, then it is attached to another spriteling, and thus positions its own rect relative
        # to where its link is
        self.link = None
        # the link direction. the first int is how far to the left (negative) or right (positive) of its
        # link this block is, and the second is how far above (negative) or below (positive)
        # (0,0) means that this block's center will always be matched to its link's center, and a +/-1 in either field
        # indicates that this block is attached to the inner side/edge of its link. +/-2 indicates an attachment
        # to the outer edge
        self.link_dir = (0, 0)

    # roots the block in place
    def place(self, root_loc):
        self.rooted = root_loc

    # attaches/links the block to another
    def attach(self, link, dir):
        self.link = link
        self.link_dir = dir

    # the update method simply returns them to their designated positions
    # DEBUG: at least it should. currently it does fuck all. Not sure why
    def update(self, *args):
        if self.rooted:
            self.rect.center = self.rooted
        elif self.link:
            x, y = self.link_dir[0], self.link_dir[1]
            if x == 0 and y == 0:
                self.rect.center = self.link.rect.center
            else:
                if x == 2:
                    self.rect.right = self.link.rect.left
                elif x == 1:
                    self.rect.left = self.link.rect.left
                elif x == 0:
                    self.rect.centerx = self.link.rect.centerx
                elif x == -1:
                    self.rect.right = self.link.rect.right
                elif x == -2:
                    self.rect.left = self.link.rect.right

                if y == 2:
                    self.rect.top = self.link.rect.bottom
                elif y == 1:
                    self.rect.bottom = self.link.rect.bottom
                elif y == 0:
                    self.rect.centery = self.link.rect.centery
                elif y == -1:
                    self.rect.top = self.link.rect.top
                elif y == -2:
                    self.rect.bottom = self.link.rect.top


# Straight up copy-pasted this stuff from my earlier project. it should work in here with limited modifications
class wall(block):
    wall_size = 65
    def __init__(self, facing, *args):
        super(wall, self).__init__(*args)
        self.hitboxes.empty()
        self.facing = facing
        if facing == 'down':
            self.hitbox = spriteling.hitbox(self,
                                            scale_y=-wall_size, bottom_side=self.rect.bottom)
        elif facing == 'top':
            self.hitbox = spriteling.hitbox(self,
                                            scale_y=-wall_size, top_side=self.rect.top)
        elif facing == 'left':
            self.hitbox = spriteling.hitbox(self,
                                            scale_x=-wall_size, left_side=self.rect.left)
        elif facing == 'right':
            self.hitbox = spriteling.hitbox(self,
                                            scale_x=-wall_size, right_side=self.rect.right)
        self.hitboxes.add(self.hitbox)


# this is for inward facing/concave corners. the orientation is specified manually by string. Not exactly elegant,
# fancy, or portable, but since there are at most four cases (and this is only ever called in room.py::class::theme),
# hardcoded constants will work
class corner(block):
    corner_size = 50
    def __init__(self, facing, *args):
        super().__init__(*args)
        self.hitboxes.empty()
        if facing == 'top_left':
            self.hitbox = (spriteling.hitbox(self,
                                             scale_x=-corner_size, scale_y=-corner_size,
                                             top_side=self.rect.top, left_side=self.rect.left))
        elif facing == 'top_right':
            self.hitbox = (spriteling.hitbox(self,
                                             scale_x=-corner_size, scale_y=-corner_size,
                                             top_side=self.rect.top, right_side=self.rect.right))
        elif facing == 'bottom_right':
            self.hitbox = (spriteling.hitbox(self,
                                             scale_x=-corner_size, scale_y=-corner_size,
                                             bottom_side=self.rect.bottom, right_side=self.rect.right))
        elif facing == 'bottom_left':
            self.hitbox = (spriteling.hitbox(self,
                                             scale_x=-corner_size, scale_y=-corner_size,
                                             bottom_side=self.rect.bottom, left_side=self.rect.left))
        self.hitboxes.add(self.hitbox)


# the floor sprite is bit tricky, as it creates a rectangular floor of the size specified and sets it as its image
# this is intended to be treated as the main image/surface of a/the room
class floor(block):
    def __init__(self, size, theme, *args):
        # passes dummy params to the parent class
        super().__init__(theme.image_lookup['f'], (0, 0))
        size_x, size_y = size[0], size[1]
        self.image = pygame.Surface((size_x * config.tile_scalar, size_y * config.tile_scalar))

        # basic loop to blit all the floor tiles into one surface
        for y in range(0, size_y+1):
            for x in range(0, size_x+1):
                self.image.blit(theme.image_lookup['f'], (x * config.tile_scalar, y * config.tile_scalar))
                #print('blitting a floor', "x = ", x, "y = ", y)

        self.rect = self.image.get_rect()

        print(self.rect)

class door(block):
    def __init__(self, **kwargs):
        # DEBUG STUFF at least the image is. UNTIL YOTOLL DRAWS A DOOR
        super().__init__(pygame.transform.scale(pygame.image.load('misc\spirit.jpg').convert_alpha(),
                                                (config.tile_scalar, config.tile_scalar)), (0, 0))
        # the kwargs are for positioning, as well as giving it a root at init (see class:blocks for what this means)
        if 'coords' in kwargs:
            self.rect.center = kwargs['coords']
        if 'root_wall' in kwargs:
            self.rect.center = kwargs['root_wall'].rect.center
        if 'side_x' in kwargs:
            self.rect.centerx = kwargs['side_x']
            self.rect.centery = (kwargs['pos']*config.tile_scalar) -50
        if 'side_y' in kwargs:
            self.rect.centery = kwargs['side_y']
            self.rect.centerx = (kwargs['pos']*config.tile_scalar) -50

    # simple, placeholder-y method that moves the player on top of the door. Will prbly be rewritten with more complex
    # behavior (that doesn't stack all the players on top of each other
    def enter(self, player):
        player.rect.center = self.rect.center

    # adjust allows you to dictate/move the side of door's rect to match a given line/value. Intended to be used within
    # room to properly line the door up with the walls
    def adjust(self, **kwargs):
        if 'left' in kwargs:
            self.rect.left = kwargs['left']
        if 'right' in kwargs:
            self.rect.right = kwargs['right']
        if 'top' in kwargs:
            self.rect.top = kwargs['top']
        if 'bottom' in kwargs:
            self.rect.bottom = kwargs['bottom']