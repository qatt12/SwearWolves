#
#              ⡤⣸⡇⣤⣤⣤⣀⣀⣀⠴⣾⣿⣿⡟⣿⠏⡏⣴⣿⣿⣿⢏⣾⣿⣿⣧⢻⣿⣿⠆⣠          ⡀   
#        ⣠⣶⣿⣿⢳⣿⡇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢸⣶⣭⣻⢿⢯⣞⡝⣿⣿⣫⢃⣛⣵⣾⣿        ⢀⣾    
#       ⣰⣿⣿⣿⣏⣿⣿⡇⣿⣿⣿⣿⣿⣿⣿⡿⣟⣯⣷⣾⢸⣿⣿⣿⣷⣿⡏⠁⣿⣿⡀⢸⣿⣿⣿⣿        ⣼⣿    
#      ⣼⣿⣿⣿⡟⣼⣿⣿⡇⣿⣿⣿⣿⡿⣟⣽⣾⣿⣿⣿⣿⡏⣿⣿⣿⣿⣿⣷⡴⠿⢟⣛⣭⣭⣭⣭⣝⣀      ⢠⣿⣿⡀   
#     ⣸⣿⣿⣿⣿⢱⣿⣿⣿⡇⣿⣿⡿⣫⣾⣿⣿⡿⣻⣵⣶⣿⣿⣷⣶⣶⣶⣶⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡀   ⢸⣿⣿⡇   
#    ⢰⣿⣿⣿⣿⡟⣾⣿⣿⣿⣧⠹⣫⣾⣿⣿⣿⣫⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆  ⢸⣿⣿⣿   
#    ⣿⣿⣿⣿⣿⡇⣿⣿⣿⣿⣿⣎⢿⣿⣿⣿⣳⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆ ⢸⣿⣿⣿⡇  
#   ⢸⣿⣿⣿⣿⣿⢹⣿⣿⣿⣿⣿⣿⣦⡻⣿⢧⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢹⣿⣿⣿⣿⣿⣿⣿⣿⣇⢿⣿⣿⣿⣿  
#   ⣾⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣿⣿⣿⡆⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠸⣿⣿⣿⣿⣿⣿⣿⠿⣿⡎⣿⣿⣿⣿⡇ 
#   ⣿⣿⣿⣿⣿⣿⡜⣿⣿⣿⣿⣿⣿⣿⡿⣹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⢻⣿⣿⣿⡿⠛⣡⣾⣿⣿⡜⣿⣿⣿⣇ 
#  ⢸⣿⣿⣿⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⢟⣵⣟⣼⣿⣟⠻⣿⣿⣿⣿⣿⣿⣿⢁⢿⣿⣿⣿⣿⣿⣿⣿⡿⣼⣎⢿⠿⢋⣴⣿⣿⣿⣿⣿⣷⡹⣿⣿⣿ 
#  ⢸⣿⣿⣿⣿⣿⣿⣧⢻⣿⣿⣿⣟⣑⣚⢍⣾⣿⣿⣿⣷⣦⣙⠻⣿⣿⣿⢧⣿⡸⣿⣿⣿⣿⣿⣿⣿⢇⣿⠟⣀⢶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣜⠿⡟ 
#  ⢸⣿⣿⣿⣿⣿⣿⣿⡘⣿⣿⣿⡿⢟⣵⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡙⠣⣿⣿⣧⢻⣿⣿⣿⣿⣿⠏⠜⡡⠞⠛⠃⠙⠿⠿⣿⣿⣿⢿⣿⣿⠿⣫⠇ 
#  ⠈⣿⣿⣿⣿⣿⣿⡟⣷⢜⣫⣽⢞⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣿⠟⠵⠷⢬⡙⢿⡜⣿⢹⣿⣿⢏⣴⠊⣠⠶⠿⢷⣦⣄⠈⢙⣛⡛⣃⣐⣶⣾⠏  
#   ⣿⣿⣿⣿⣿⣿⣧⣿⣿⣔⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠂⣠⡤⠴⠦⢤⣙⣿⣧⠛⣼⠟⣡⣾⣿⣾⣿⡗  ⠹⣿⣆⠈⣙⡇⣿⣿⡿⠋   
#   ⢸⣿⣿⣿⣿⣿⣿⢉⣾⣿⣿⣿⣿⣿⣿⣿⡿⠿⠟⠃⢠⣾⣿⡷   ⠻⣿⣿⣴⣷⣿⣿⣿⣿⡇⠉    ⢻⣿⡆⢿⣇⠛⠉     
#   ⠘⣿⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣶⣤⣲⣶⣾⠿⢀⣿⣿⠙⠁   ⡀⢻⣿⣿⣿⣿⣿⣿⣿⣧⠰⣄⣀⣠⡇⢸⣿⣧⢺⣿⡄      
#    ⣿⣿⣿⣿⣿⣿⡏⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⡇⢸⣿⣷⠠⣄⡀⢀⣰⡇⣸⣿⣿⣿⣿⣿⣿⣿⣿⣦⡙⠿⠿⣡⣿⢿⣿⡏⣿⣷⡀     
#    ⢻⣿⣿⣿⣿⣿⣿⣹⣿⣿⣿⣿⢏⣽⢸⣿⣿⣧⠘⣿⣿⣆⠙⠿⠿⢟⣵⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⢲⢮⡿⣽⣷⣿⣿⣷     
#    ⣸⣿⣿⣿⣿⣿⣿⣧⢿⣿⣿⡏⣾⣯⡍⣿⣿⣿⡼⣯⣟⣛⣻⢶⢼⣟⣿⣿⣿⣿⣿⣿⣿⠿⠿⣿⣿⣿⠿⣫⣏⣾⢳⢳⢇⣿⣿⡿⡇    
#   ⣿⣟⣿⣿⣿⣿⣿⣿⣎⢿⣿⡇⣿⡿⡇⢻⣿⣿⣷⣝⠳⠷⢯⢏⣟⣾⡏⣙⣛⢛⣋⣥⣶⣶⣦⣄⡀⠐⠆⣿⣿⣿⣟⣫⢾⣿⣿⡇⠃    
#   ⡸⠋⣼⣿⣿⣿⣿⣿⣿⣿⣯⢿⣿⡜⠋⢀⡌⣿⣿⣿⣮⡩⢾⣯⣾⣿⣿⡇⣧⣣⣾⣿⣿⣿⣿⣿⣿⣿⣦ ⣿⣿⣿⣿⢏⣿⣿⠟⠁     
#    ⣸⣿⣿⣿⣿⣿⣿⣿⣿⢟⣽⣿⠃ ⣾⣿⡘⢿⣿⣿⣿⣷⡮⣹⣿⣿⡇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢱⣿⣿⣿⣋⠚⣩⡵⣸      
#   ⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⢦⣇ ⣿⣿⣿⣤⠓⠈⢽⣭⣾⣿⣿⣿⣷⡘⣿⣿⣿⣿⣿⣿⣿⣿⠟⣡⣿⣿⡿⢛⡁⠘⢛⣱⡇      
#   ⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡱⢿⣿⣦⡘⠿⠿⢟⣱⣶⣤⣽⡻⢿⣿⣿⣿⣿⣮⣙⠻⠿⠿⠟⣋⣡⣾⠿⢛⣥⣶⣿⣧⡀ ⠛       
#  ⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣾⣿⣶⣻⣿⣿⡏⠛⠿⡟⣫⠁⠸⢭⣝⣛⣛⣛⠿⡟⠛⢋⣭⣥⣶⣾⡟⠛⠋⢉⣁ 
#  ⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢛⣛⠓⠉⠛⠇⣀⣤⠶⢎⠠⠇ ⣀⠈⢉⡉⠉⢀⡀⠰ ⠉⠉⠉⠉
#  ⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡎⡳⠂ ⣠⡾⣫⣶⣿⣿⣷⣦⣄⣉⣀⣈⣁⣀⣠⣤⣾⣶⣦⣄⡀ 
#  ⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢟⠋⡱⠁ ⡰⡟⠑⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿

import pygame, config, interface, events
from events import event_maker
from misc import controller_list as controller_list
from collections import deque
import time

pygame.init()

game_window = pygame.display.set_mode(config.screen_size)
clock = pygame.time.Clock()

event_maker.make_entry('log', 'startup', 'startup has been successful', 'driver')
#sounds and music checker
#pygame.mixer.music.load('Music/LoLD.ogg')
#pygame.mixer.music.play(-1)


pillar_of_hate = pygame.sprite.LayeredUpdates()


# important class that does its name: handles the screen
class screen_handler():
    def __init__(self, display, pillar):
        event_maker.make_entry('log', 'game_window size', " ", 'driver', False, False, 'screen')
        self.disp = pygame.Surface(config.screen_size)
        self.size = config.screen_size
        # LOGAN: setting up some important containers/labels.
        self.menus = pygame.sprite.LayeredUpdates()
        self.player_one = None
        self.player_index = 0
        self.ordered_list_of_player_HANDLERS = []
        self.GROUP_of_player_SPRITES = pygame.sprite.Group()
        self.current_room = None
        self.overlays = []

        self.all_missiles     = pygame.sprite.Group()
        self.player_missiles  = pygame.sprite.Group()
        self.enemy_missiles   = pygame.sprite.Group()

        self.active_enemies   = pygame.sprite.Group()
        self.allies           = pygame.sprite.Group()

        self.list_allies = []
        self.list_players = []

        self.obstacles        = pygame.sprite.Group()
        self.apply_to_players = pygame.sprite.Group()
        self.apply_to_enemies = pygame.sprite.Group()

    # currently, update does a lot of things. It is used to add many things to the screen, to keep everything elegant
    # and avoid having to write many dif methods, but this may not be a great idea, as update is also used/assumed to
    # indicate the passage of time. this apply method is the new way to adjust what is in the screen handler.
    def apply(self, *args, **kwargs):
        message = events.entry('log', 'new menu', 'added a new menu', 'driver',
                               loc_src='screen.apply()')
        if 'opened_menus' in kwargs:
            pillar_of_hate.add(kwargs['opened_menus'], layer=config.menu_layer)
            self.menus.add(kwargs['opened_menus'])
            message.modify(opened_menu=kwargs['opened_menus'])
        if 'closed_menus' in kwargs:
            pillar_of_hate.remove(kwargs['closed_menus'])
            self.menus.remove(kwargs['closed_menus'])
            message.modify(closed_menu=kwargs['closed_menus'])
        if 'player_one' in kwargs:
            self.player_one = (kwargs['player_one'])
            self.player_index = 1
            self.ordered_list_of_player_HANDLERS = [self.player_one]
            message.modify(set_player_one=kwargs['player_one'])
        if 'next_player' in kwargs:
            self.ordered_list_of_player_HANDLERS.append(kwargs['next_player'])
            self.player_index += 1
            message.modify(next_player=kwargs['next_player'])

        if 'dead_player' in kwargs:
            self.ordered_list_of_player_HANDLERS.remove(kwargs['dead_player'])
            if kwargs['dead_player'] == self.player_one:
                if len(self.ordered_list_of_player_HANDLERS) >= 1:
                    self.player_one = self.ordered_list_of_player_HANDLERS[0]
                else:
                    event_maker.new_event(events.game_state_event, "driver", subtype=events.game_over)
                    ded = pygame.image.load('Animation\img_death.png').convert()

                    time.sleep(3)
                    pygame.quit()

        if 'room' in kwargs:
            self.kill_it_all()
            self.current_room = kwargs['room']
            message.modify(room=kwargs['room'])
            for x in range(0, config.player_layer):
                pillar_of_hate.remove_sprites_of_layer(x)
            for x in range(config.enemy_layer, config.air_layer):
                pillar_of_hate.remove_sprites_of_layer(x)
            for each in kwargs['room'].get_contents():
                pillar_of_hate.add(each, layer=each.layer)
            for each in kwargs['room'].pull_enemies():
                pillar_of_hate.add(each, layer=each.layer)
                self.active_enemies.add(each)
        if 'overlay' in kwargs:
            self.overlays.append(kwargs['overlay'])
            message.modify(overlay=kwargs['overlay'])
            pillar_of_hate.add(kwargs['overlay'], layer=kwargs['overlay'].layer)
        if 'spawn_aura' in kwargs:
            pillar_of_hate.add(kwargs['spawn_aura'], layer=kwargs['spawn_aura'].layer)
            self.apply_to_players.add(kwargs['spawn_aura'])
            print("new aura: ", kwargs['spawn_aura'])
        if 'spawn_obstacle' in kwargs:
            pillar_of_hate.add(kwargs['spawn_obstacle'], layer=kwargs['spawn_obstacle'].layer)
            self.obstacles.add(kwargs['spawn_obstacle'])
        if 'spawn_ally' in kwargs:
            pillar_of_hate.add(kwargs['spawn_ally'], layer=kwargs['spawn_ally'].layer)
            self.allies.add(kwargs['spawn_ally'])
        if 'spawn_enemy' in kwargs:
            enemy_list = self.current_room.spawn_enemy(kwargs['spawn_enemy'][0], kwargs['spawn_enemy'][1])
            for nme in enemy_list:
                pillar_of_hate.add(nme, layer=nme.layer)
                self.active_enemies.add(nme)
        #if 'spawn_trap' in kwargs:
        #    enemy_list = self.current_room.spawn_trap(kwargs['spawn_trap'])
        #    for nme in enemy_list:
        #        pillar_of_hate.add(nme, layer=nme.layer)
        #        self.active_enemies.add(nme)

        event_maker.send_entry(message, False, False)

    def kill_it_all(self):
        for each in self.all_missiles:
            each.kill()
        for each in self.active_enemies:
            each.kill()
        for each in self.allies:
            each.kill()
        self.list_allies   = []
        self.list_players  = []

        self.obstacles.empty()
        self.apply_to_players.empty()
        self.apply_to_enemies.empty()

    def update(self, *args, **kwargs):
        self.menus.update()
        self.all_missiles.update()
        self.active_enemies.update()
        try:
            assert (self.player_index == interface.handler.get_player_interface_num()), "this would create an error"
        except AssertionError:
            print(AssertionError, "index= ", self.player_index, "num_interfaces= ",
                  interface.handler.get_player_interface_num())

        if self.current_room is not None:
            self.current_room.update(self.player_one.player, self.GROUP_of_player_SPRITES)
            self.current_room.collide_walls(players=self.GROUP_of_player_SPRITES)
            self.current_room.collide_doors(self.GROUP_of_player_SPRITES)


            for player_handler in self.ordered_list_of_player_HANDLERS:
                other_players = deque(self.GROUP_of_player_SPRITES)
                other_players.remove(player_handler.player)
                player_handler.update(players=other_players, enemies=self.current_room.pull_enemies(), allies=self.list_allies,
                                      me=player_handler.player, all_players=self.GROUP_of_player_SPRITES)

                for each in player_handler.get_missiles():
                    pillar_of_hate.add(each, layer=each.layer)
                for each in player_handler.get_impacts():
                    pillar_of_hate.add(each, layer=each.layer)

                self.all_missiles.add(player_handler.get_impacts())

                self.player_missiles.add(player_handler.get_missiles())
                player_handler.missiles.empty()

                if player_handler.get_spells()['refresh']:
                    pillar_of_hate.remove_sprites_of_layer(player_handler.spell_layer)
                    pillar_of_hate.add(player_handler.get_spells()['active'],
                                       layer=player_handler.spell_layer)
            for each in self.active_enemies:
                self.enemy_missiles.add(each.get_missiles())
                each.missiles.empty()

            self.all_missiles.add(self.player_missiles, self.enemy_missiles)

            self.collide_missiles_into(self.player_missiles, self.active_enemies)
            self.collide_missiles_into(self.enemy_missiles, self.GROUP_of_player_SPRITES)
            self.collide_missiles_into(self.apply_to_players, self.GROUP_of_player_SPRITES)
            self.enemies_attack(self.active_enemies, self.GROUP_of_player_SPRITES)

            self.current_room.collide_walls(missiles=self.all_missiles, enemies=self.active_enemies,
                                            #obstacles=self.obstacles
                                            )

    def collide_missiles_into(self, incoming, receiving):
        dings = pygame.sprite.groupcollide(incoming, receiving, False, False,
                                           spriteling.collide_hitbox)
        for each in dings:
            for every in dings[each]:
                each(every)

    def enemies_attack(self, aggressors, players):
        dings = pygame.sprite.groupcollide(aggressors, players, False, False,
                                           enemies.can_attack)
        for each in dings:
            for every in dings[each]:
                each.attack(every)

    def draw(self, display):

        # I FINALLY GOT EVERYTHING INTO THE PILLAR OF HATE IT
        # SHOULD WORK, AND IT FUCKING BETTER BE FASTER THAN THE OLD WAY
        display.fill(config.black)
        pygame.display.update(pillar_of_hate.draw(display))

        #if self.current_room is not None:
        #    self.current_room.draw_contents(self.disp, True)
        #    for each in self.ordered_list_of_player_HANDLERS:
        #        each.draw(self.disp, True)
        #for each in self.all_missiles:
        #    each.draw(self.disp, True)
        #for each in self.active_enemies:
        #    each.draw(self.disp, True)
        #for each in self.obstacles:
        #    each.draw_boxes(self.disp)
###
        #display.blit(self.disp, (0, 0))
        #self.menus.draw(display)
        #for each in self.overlays:
        #    each.draw(display)
        #pygame.display.flip()

    # LOGAN: this method performs the last bits of preparation necessary before the actual game can begin. It tells each
    #  handler to generate a proper player sprite and put it in screen's group of player sprites, then creates and
    # attaches their HUDS
    def game_start(self, player_constr, starting_room):
        from spriteling import spriteling
        assert (len(self.ordered_list_of_player_HANDLERS) >=1), "nothing is in player handlers"
        i = 1
        self.list_players = [each.player for each in self.ordered_list_of_player_HANDLERS]
        for each in self.ordered_list_of_player_HANDLERS:
            each.begin_game(player_constr, starting_room, i)
            self.GROUP_of_player_SPRITES.add(each.player)
            pillar_of_hate.add(each.player, layer=each.layer)
            i += 1
            assert (each.player is not None), "each.player DNEs"
            assert (isinstance(each.player, spriteling)), "wrong type; not a sprite"
            self.apply(overlay=each.get_hud())


# these booleans are for the game loops, to keep everything running in the state loop in which it belongs
running = True
start_loop = True
player_select_loop = True
game_loop = True


import menu

# LOGAN: the event_handler is a little anaemic right now, but for the life of me I can't figure out what/how much should
#  go there

# the start menu was... challenging to get working.
# LOGAN: in order to get the window to continuously check for and accept controllers, I had to make a dedicated
# controller list class.
controller_handler = controller_list()

start_menu = menu.menu(game_window.get_rect())
screen = screen_handler(game_window, pillar_of_hate)
screen.apply(opened_menus=start_menu)
player_one_HANDLER = None

while(start_loop and running):
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == events.game_state_event:
            start_loop = False

    if controller_handler.is_p1_ready():
        player_one_HANDLER = controller_handler.get_p1()
        event_maker.make_entry('log', 'FIRST PLAYER', 'player one has pressed start, we should be leaving start loop now', 'driver', True, False,
                               'crucial', 'start_loop', 'ready_up', 'player_one',
                               loc_src='start_loop', player_one_Handler=player_one_HANDLER, num_player_handlers=interface.handler.get_player_interface_num())
        screen.apply(player_one=player_one_HANDLER, closed_menus=start_menu)
        assert (screen.player_one is not None), "failed to add player one"
        event_maker.new_event(events.game_state_event, subtype=events.game_state_event, file_src='driver', exit='start_loop', player_one=player_one_HANDLER)
        start_loop = False
        start_menu.kill()

    controller_handler.update()

    screen.update()
    screen.draw(game_window)

    clock.tick(config.fps)
    pygame.display.update()
    pygame.event.pump()
    pygame.time.wait(0)

game_window.fill((0, 0, 0))

import spells

unlocked_books = [spells.DEBUG_book(spells.cold_snap_s, spells.spawn_default, spells.spawn_node_sniper,  spells.spawn_abenenoemy, spells.spawn_quintenemy,
    spells.petal_storm_s, spells.pestilence_s,  spells.flak_cannon_s, spells.DEBUG_unguided_swarm,
                                    spells.fissure_s, spells.heatwave_s, spells.cold_snap_s,
                                    spells.iceshard_s, spells.icebeam_s, spells.solar_beam_s, spells.beacon_of_hope,
                                    spells.hydro_pump_s, spells.poison_spore_s, spells.chain_gun_s,
                                    spells.razor_leaf_s),
                  spells.book_of_fire(4),
                  spells.book_of_rock(4),
                  spells.book_of_acid(4),
                  spells.book_of_ice(4),
                  #spells.book_of_light(3),
                  spells.book_of_leaves(4),
                  #spells.book_of_waves(3),
                  ]

player_num = 1
p1_char_select = menu.player_select_menu(1, unlocked_books)
p2_char_select = menu.player_select_menu(2, unlocked_books)
p3_char_select = menu.player_select_menu(3, unlocked_books)
p4_char_select = menu.player_select_menu(4, unlocked_books)

screen.apply(opened_menus=p1_char_select)
print(screen)
ready_players = 0
player_one_HANDLER.attach(menu=p1_char_select, name="player one")
banned_list = []

while(player_select_loop and running):
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    if ready_players >= player_num:
        player_select_loop = False

    controller_handler.update()
    if controller_handler.is_next_ready():
        event_maker.make_entry('log', 'next_player', "found next player", 'driver', False, False,
                               'controller', 'player_initialization', 'player_tally',
                               player=player_num)
        if player_num == 1:
            event_maker.make_entry('log', 'next_player', "player num is 1, now 2", 'driver', False, False,
                                   'controller', 'player_initialization', 'player_tally')
            player_num = 2
            player_two_HANDLER = controller_handler.get_next_player()
            player_two_HANDLER.attach(menu=p2_char_select, name='player two')
            screen.apply(next_player=player_two_HANDLER, opened_menus=p2_char_select)
        elif player_num == 2:
            event_maker.make_entry('log', 'next_player', "player num is 2, now 3", 'driver', False, False,
                                   'controller', 'player_initialization', 'player_tally')
            player_num = 3
            player_three_HANDLER = controller_handler.get_next_player()
            player_three_HANDLER.attach(menu=p3_char_select, name='player three')
            screen.apply(next_player=player_three_HANDLER, opened_menus=p3_char_select)
        elif player_num == 3:
            event_maker.make_entry('log', 'next_player', "player num is 3, now 4", 'driver', False, False,
                                   'controller', 'player_initialization', 'player_tally')
            player_num = 4
            player_four_HANDLER = controller_handler.get_next_player()
            player_four_HANDLER.attach(menu=p4_char_select, name="player four")
            screen.apply(next_player=player_four_HANDLER, opened_menus=p4_char_select)
        if player_num > 1:
            try:
                assert (screen.player_index >= player_num), "tried and failed to add next player"
            except AssertionError as error:
                event_maker.make_entry('error', 'player index error', str(error), 'driver', True, True)
                print(error)
                print("screen's player index= ", screen.player_index, "player num= ", player_num)
                print("player handlers in screen: ", screen.ordered_list_of_player_HANDLERS)

    screen.update()
    screen.draw(game_window)
    for each in screen.menus:
        pick = each.is_ready()
        if pick != -1 and pick not in banned_list:
            assert (pick not in banned_list), "invalid pick"
            banned_list.append(pick)
            ready_players += 1
            print("ready_players= ", ready_players, "player_num= ", player_num)
            for every in screen.menus:
                every.ban_book(pick)
                every.next_book()

    for each in screen.ordered_list_of_player_HANDLERS:
        each.update_menu()

    screen.draw(game_window)

    clock.tick(config.fps)
    pygame.display.update()
    pygame.event.pump()
    pygame.time.wait(0)

player_sprites = pygame.sprite.Group()

screen.apply(closed_menus=(p1_char_select, p2_char_select, p3_char_select, p4_char_select))

game_window.fill((0, 0, 0))
import room, player, enemies, spriteling
# scope tomfoolery
plyr = player.multiplayer


DEBUG_dungeon = room.basic_dungeon(game_window)
screen.apply(room=DEBUG_dungeon())

#event_maker.new_event(events.spriteling_event, 'driver', subtype=events.spawn_enemy, spawn_enemy=(enemies.abenenoemy,1))

# may replace this with some event driven progging
screen.game_start(plyr, DEBUG_dungeon.get_hub())

while(game_loop and running):
    for event in pygame.event.get():
        event_maker.make_entry('event', 'events', "the received events", 'driver', False, True, 'events', 'DEBUG', "basic", log_entry=event)
        if event.type == pygame.QUIT:
            running = False
        if event.type == events.player_event:
            if event.subtype == events.player_died:
                screen.apply(dead_player=event.dead_player)
        if event.type == events.room_event:
            if event.subtype == events.next_room:
                screen.apply(room=DEBUG_dungeon.next_room(screen.GROUP_of_player_SPRITES))
                event_maker.make_entry('trace', "used exit door", "successful", 'driver', True, True)
            elif event.subtype == events.to_hub:
                screen.apply(room=DEBUG_dungeon.go_to_hub(screen.GROUP_of_player_SPRITES))
                event_maker.make_entry('trace', "back to the hub", "successful", 'driver', True, True)
            elif event.subtype == events.next_floor:
                screen.apply(room=DEBUG_dungeon.next_room(screen.GROUP_of_player_SPRITES))
                event_maker.make_entry('trace', "used exit door", "successful", 'driver', True, True)
            elif event.subtype == events.prev_floor:
                screen.apply(room=DEBUG_dungeon.next_room(screen.GROUP_of_player_SPRITES))
                event_maker.make_entry('trace', "used exit door", "successful", 'driver', True, True)
        if event.type == events.game_state_event:
            if event.subtype == 'end_game':
                running = False
        if event.type == events.spriteling_event:
            if event.subtype == 'death':
                event_maker.make_entry("log", 'detected dead spriteling at event level', "", "driver")
            elif event.subtype == events.spawn_aura:
                screen.apply(spawn_aura=event.spawn_aura)
            elif event.subtype == events.spawn_obstacle:
                screen.apply(spawn_obstacle=event.spawn_obstacle)
            elif event.subtype == events.spawn_ally:
                screen.apply(spawn_ally=event.spawn_ally)

            elif event.subtype == events.spawn_enemy:
                screen.apply(spawn_enemy=event.spawn_enemy)
            elif event.subtype == events.spawn_obstacle:
                screen.apply(spawn_obstacle=event.spawn_obstacle)
            elif event.subtype == events.spawn_trap:
                screen.apply(spawn_trap=event.spawn_trap)
        if event.type >= pygame.USEREVENT:
            event_maker.make_entry('event', 'events', "user events", 'driver', False, True, 'events', 'DEBUG', 'user',
                                   "basic", log_entry=event)

   # class spawn_quintenemy(spell):
    #    def __init__(self, **kwargs):
     #       super().__init__(quintenemy_spawn_m, **kwargs)

#    class quintenemy_spawn_m(spawn_enemy_m):
 #       def __init__(self, *args, **kwargs):
  #          super().__init__(enemies.quintenemy)
    screen.draw(game_window)
    screen.update()

    clock.tick(config.fps)
    #print(clock.get_fps())
    pygame.event.pump()
    #pygame.time.wait(0)

event_maker.flush_trace_buffer("Flushing on close", False)
