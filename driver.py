#
#              ⡤⣸⡇⣤⣤⣤⣀⣀⣀⠴⣾⣿⣿⡟⣿⠏⡏⣴⣿⣿⣿⢏⣾⣿⣿⣧⢻⣿⣿⠆⣠          ⡀   
#        ⣠⣶⣿⣿⢳⣿⡇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢸⣶⣭⣻⢿⢯⣞⡝⣿⣿⣫⢃⣛⣵⣾⣿        ⢀⣾    
#       ⣰⣿⣿⣿⣏⣿⣿⡇⣿⣿⣿⣿⣿⣿⣿⡿⣟⣯⣷⣾⢸⣿⣿⣿⣷⣿⡏⠁⣿⣿⡀⢸⣿⣿⣿⣿        ⣼⣿    
#      ⣼⣿⣿⣿⡟⣼⣿⣿⡇⣿⣿⣿⣿⡿⣟⣽⣾⣿⣿⣿⣿⡏⣿⣿⣿⣿⣿⣷⡴⠿⢟⣛⣭⣭⣭⣭⣝⣀      ⢠⣿⣿⡀   
#     ⣸⣿⣿⣿⣿⢱⣿⣿⣿⡇⣿⣿⡿⣫⣾⣿⣿⡿⣻⣵⣶⣿⣿⣷⣶⣶⣶⣶⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡀   ⢸⣿⣿⡇   
#    ⢰⣿⣿⣿⣿⡟⣾⣿⣿⣿⣧⠹⣫⣾⣿⣿⣿⣫⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆  ⢸⣿⣿⣿   
#    ⣿⣿⣿⣿⣿⡇⣿⣿⣿⣿⣿⣎⢿⣿⣿⣿⣳⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆ ⢸⣿⣿⣿⡇  
#   ⢸⣿⣿⣿⣿⣿⢹⣿⣿⣿⣿⣿⣿⣦⡻⣿⢧⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢹⣿⣿⣿⣿⣿⣿⣿⣿⣇⢿⣿⣿⣿⣿  
#   ⣾⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣿⣿⣿⡆⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠸⣿⣿⣿⣿⣿⣿⣿⠿⣿⡎⣿⣿⣿⣿⡇ 
#   ⣿⣿⣿⣿⣿⣿⡜⣿⣿⣿⣿⣿⣿⣿⡿⣹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⢻⣿⣿⣿⡿⠛⣡⣾⣿⣿⡜⣿⣿⣿⣇ 
#  ⢸⣿⣿⣿⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⢟⣵⣟⣼⣿⣟⠻⣿⣿⣿⣿⣿⣿⣿⢁⢿⣿⣿⣿⣿⣿⣿⣿⡿⣼⣎⢿⠿⢋⣴⣿⣿⣿⣿⣿⣷⡹⣿⣿⣿ 
#  ⢸⣿⣿⣿⣿⣿⣿⣧⢻⣿⣿⣿⣟⣑⣚⢍⣾⣿⣿⣿⣷⣦⣙⠻⣿⣿⣿⢧⣿⡸⣿⣿⣿⣿⣿⣿⣿⢇⣿⠟⣀⢶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣜⠿⡟ 
#  ⢸⣿⣿⣿⣿⣿⣿⣿⡘⣿⣿⣿⡿⢟⣵⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡙⠣⣿⣿⣧⢻⣿⣿⣿⣿⣿⠏⠜⡡⠞⠛⠃⠙⠿⠿⣿⣿⣿⢿⣿⣿⠿⣫⠇ 
#  ⠈⣿⣿⣿⣿⣿⣿⡟⣷⢜⣫⣽⢞⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿⣿⠟⠵⠷⢬⡙⢿⡜⣿⢹⣿⣿⢏⣴⠊⣠⠶⠿⢷⣦⣄⠈⢙⣛⡛⣃⣐⣶⣾⠏  
#   ⣿⣿⣿⣿⣿⣿⣧⣿⣿⣔⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠂⣠⡤⠴⠦⢤⣙⣿⣧⠛⣼⠟⣡⣾⣿⣾⣿⡗  ⠹⣿⣆⠈⣙⡇⣿⣿⡿⠋   
#   ⢸⣿⣿⣿⣿⣿⣿⢉⣾⣿⣿⣿⣿⣿⣿⣿⡿⠿⠟⠃⢠⣾⣿⡷   ⠻⣿⣿⣴⣷⣿⣿⣿⣿⡇⠉    ⢻⣿⡆⢿⣇⠛⠉     
#   ⠘⣿⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣶⣤⣲⣶⣾⠿⢀⣿⣿⠙⠁   ⡀⢻⣿⣿⣿⣿⣿⣿⣿⣧⠰⣄⣀⣠⡇⢸⣿⣧⢺⣿⡄      
#    ⣿⣿⣿⣿⣿⣿⡏⣿⣿⣿⣿⣿⣿⣿⢻⣿⣿⡇⢸⣿⣷⠠⣄⡀⢀⣰⡇⣸⣿⣿⣿⣿⣿⣿⣿⣿⣦⡙⠿⠿⣡⣿⢿⣿⡏⣿⣷⡀     
#    ⢻⣿⣿⣿⣿⣿⣿⣹⣿⣿⣿⣿⢏⣽⢸⣿⣿⣧⠘⣿⣿⣆⠙⠿⠿⢟⣵⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⢲⢮⡿⣽⣷⣿⣿⣷     
#    ⣸⣿⣿⣿⣿⣿⣿⣧⢿⣿⣿⡏⣾⣯⡍⣿⣿⣿⡼⣯⣟⣛⣻⢶⢼⣟⣿⣿⣿⣿⣿⣿⣿⠿⠿⣿⣿⣿⠿⣫⣏⣾⢳⢳⢇⣿⣿⡿⡇    
#   ⣿⣟⣿⣿⣿⣿⣿⣿⣎⢿⣿⡇⣿⡿⡇⢻⣿⣿⣷⣝⠳⠷⢯⢏⣟⣾⡏⣙⣛⢛⣋⣥⣶⣶⣦⣄⡀⠐⠆⣿⣿⣿⣟⣫⢾⣿⣿⡇⠃    
#   ⡸⠋⣼⣿⣿⣿⣿⣿⣿⣿⣯⢿⣿⡜⠋⢀⡌⣿⣿⣿⣮⡩⢾⣯⣾⣿⣿⡇⣧⣣⣾⣿⣿⣿⣿⣿⣿⣿⣦ ⣿⣿⣿⣿⢏⣿⣿⠟⠁     
#    ⣸⣿⣿⣿⣿⣿⣿⣿⣿⢟⣽⣿⠃ ⣾⣿⡘⢿⣿⣿⣿⣷⡮⣹⣿⣿⡇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢱⣿⣿⣿⣋⠚⣩⡵⣸      
#   ⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⢦⣇ ⣿⣿⣿⣤⠓⠈⢽⣭⣾⣿⣿⣿⣷⡘⣿⣿⣿⣿⣿⣿⣿⣿⠟⣡⣿⣿⡿⢛⡁⠘⢛⣱⡇      
#   ⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡱⢿⣿⣦⡘⠿⠿⢟⣱⣶⣤⣽⡻⢿⣿⣿⣿⣿⣮⣙⠻⠿⠿⠟⣋⣡⣾⠿⢛⣥⣶⣿⣧⡀ ⠛       
#  ⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣾⣿⣶⣻⣿⣿⡏⠛⠿⡟⣫⠁⠸⢭⣝⣛⣛⣛⠿⡟⠛⢋⣭⣥⣶⣾⡟⠛⠋⢉⣁ 
#  ⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢛⣛⠓⠉⠛⠇⣀⣤⠶⢎⠠⠇ ⣀⠈⢉⡉⠉⢀⡀⠰ ⠉⠉⠉⠉
#  ⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡎⡳⠂ ⣠⡾⣫⣶⣿⣿⣷⣦⣄⣉⣀⣈⣁⣀⣠⣤⣾⣶⣦⣄⡀ 
#  ⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢟⠋⡱⠁ ⡰⡟⠑⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿

import pygame, config, interface
from misc import controller_list as controller_list
pygame.init()

game_window = pygame.display.set_mode(config.screen_size)
clock = pygame.time.Clock()


# very basic rect calculating class designed to break the display window into several smaller rects so that the screen
#  can be updated in blocks
class partial_render():
    # LOGAN: frag is the number of sub-rects that the display screen will be divided into
    def __init__(self, frag):
        self.segments = []
        seg_size = int(config.screen_width/frag)
        try:
            assert (isinstance(seg_size, int)), "seg_size is not an int"
        except AssertionError:
            print(AssertionError, "seg_szie= ", seg_size)

        for x in range(0, frag):
            self.segments.append(pygame.rect.Rect((x*seg_size, 0), (seg_size, config.screen_height)))
        self.index = 0

    # LOGAN: once you've decided on how many sections of screen you want, simply calling the instance will return a rect
    #  of the calculated size and position
    def __call__(self, *args, **kwargs):
        ret = self.segments[self.index]
        self.index += 1
        if self.index >= len(self.segments):
            self.index = 0
        return ret


# important class that does its name: handles the screen
class screen_handler():
    def __init__(self, display):
        print("display rect is : ", display.get_rect())
        self.disp = pygame.Surface(config.screen_size)
        self.size = config.screen_size

        # LOGAN: scroll_bounds is a rect that is used to determine when the screen needs to be scrolled in a particular
        # direction, and how fast it needs to scroll
        self.scroll_bounds = pygame.rect.Rect((0, 0), (config.screen_width-100, config.screen_height-100))
        self.scroll_bounds.center = display.get_rect().center

        # the partial render rect
        self.render_rect = partial_render(3)

        # LOGAN: setting up some important containers/labels.
        self.menus = pygame.sprite.Group()
        self.player_one = None
        self.player_index = 0
        self.ordered_list_of_player_HANDLERS = []
        self.GROUP_of_player_SPRITES = pygame.sprite.Group()
        self.current_room = None
        self.overlays = []

        self.game_state = 'start_loop'


    # currently, update does a lot of things. It is used to add many things to the screen, to keep everything elegant
    # and avoid having to write many dif methods, but this may not be a great idea, as update is also used/assumed to
    # indicate the passage of time. this apply method is the new way to adjust what is in the screen handler.
    def apply(self, *args, **kwargs):
        if 'opened_menus' in kwargs:
            self.menus.add(kwargs['opened_menus'])
            print("added new menu: ")
        if 'closed_menus' in kwargs:
            self.menus.remove(kwargs['closed_menus'])
        if 'player_one' in kwargs:
            self.player_one = (kwargs['player_one'])
            self.player_index = 1
            self.ordered_list_of_player_HANDLERS = [self.player_one]
        if 'next_player' in kwargs:
            self.ordered_list_of_player_HANDLERS.append(kwargs['next_player'])
            self.player_index += 1
        if 'room' in kwargs:
            self.current_room = kwargs['room']
        if 'overlay' in kwargs:
            self.overlays.append(kwargs['overlay'])

    def update(self, *args, **kwargs):
        self.menus.update()
        try:
            assert (self.player_index == interface.handler.get_player_interface_num()), "this would create an error"
        except AssertionError:
            print(AssertionError, "index= ", self.player_index, "num_interfaces= ", interface.handler.get_player_interface_num())

        if self.current_room is not None:
            self.current_room.update(self.player_one.player.rect, self.GROUP_of_player_SPRITES)
            self.current_room.collide_walls(players=self.GROUP_of_player_SPRITES)
            self.current_room.collide_doors(self.GROUP_of_player_SPRITES)

            visible_enemies = self.current_room.pull_enemies(True)
            for player in self.ordered_list_of_player_HANDLERS:
                player.update(all_players=self.GROUP_of_player_SPRITES, known_enemies=visible_enemies)

    def draw(self, display, scroll=(0, 0)):
        display.fill(config.black)

        if self.current_room is not None:
            self.current_room.draw_contents(self.disp)
            self.current_room.draw_boxes(self.disp)

            for each in self.ordered_list_of_player_HANDLERS:
                each.draw(self.disp)

        display.blit(self.disp, scroll)
        self.menus.draw(display)
        for each in self.overlays:
            each.draw(display)
        pygame.draw.rect(display, config.black, self.scroll_bounds, 4)

        #pygame.display.update(self.render_rect())
        pygame.display.flip()
        #pygame.display.update()

    # LOGAN: this method performs the last bits of preparation necessary before the actual game can begin. It tells each
    #  handler to generate a proper player sprite and put it in screen's group of player sprites, then creates and
    # attaches their HUDS
    def game_start(self, player_constr, starting_room):
        from spriteling import spriteling
        assert (len(self.ordered_list_of_player_HANDLERS) >=1), "nothing is in player handlers"
        i = 1
        for each in self.ordered_list_of_player_HANDLERS:
            each.begin_game(player_constr, starting_room, i)
            self.GROUP_of_player_SPRITES.add(each.player)
            i += 1
            assert (each.player is not None), "each.player DNEs"
            assert (isinstance(each.player, spriteling)), "wrong type; not a sprite"
            try:
                self.GROUP_of_player_SPRITES.__contains__(each)
            except:
                print("failed to add sprites; you passed in ", type(each))
            self.apply(overlay=each.get_hud())


# these booleans are for the game loops, to keep everything running in the state loop in which it belongs
running = True
start_loop = True
player_select_loop = True
game_loop = True
print("entering start loop")

import menu
import events

# LOGAN: the event_handler is a little anaemic right now, but for the life of me I can't figure out what/how much should
#  go there
event_maker = events.event_handler(1)

# the start menu was... challenging to get working.
# LOGAN: in order to get the window to continuously check for and accept controllers, I had to make a dedicated
# controller list class.
controller_handler = controller_list()

start_menu = menu.menu(game_window.get_rect())
screen = screen_handler(game_window)
screen.apply(opened_menus=start_menu)
player_one_HANDLER = None

while(start_loop and running):
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == events.exit_start:
            start_loop = False

    if controller_handler.is_p1_ready():
        player_one_HANDLER = controller_handler.get_p1()
        print("player one handler is of type: ", type(player_one_HANDLER))
        print("player one handler's controller is of type: ", type(player_one_HANDLER.controller))
        screen.apply(player_one=player_one_HANDLER, closed_menus=start_menu)
        assert (screen.player_one is not None), "failed to add player one"
        event_maker.game_state_event(events.exit_start)
        start_loop = False
        start_menu.kill()

    controller_handler.update()

    screen.update()
    screen.draw(game_window)

    clock.tick(config.fps)
    pygame.display.update()
    pygame.event.pump()
    pygame.time.wait(0)

game_window.fill((0, 0, 0))

import spells

unlocked_books = [spells.DEBUG_book(spells.curse_s, spells.heal_s, spells.arc_DEBUG_s),
                  spells.book_of_fire(3), spells.book_of_acid(3), spells.book_of_ice(3), spells.book_of_light(3)]

player_num = 1
p1_char_select = menu.player_select_menu(1, unlocked_books)
p2_char_select = menu.player_select_menu(2, unlocked_books)
p3_char_select = menu.player_select_menu(3, unlocked_books)
p4_char_select = menu.player_select_menu(4, unlocked_books)

screen.apply(opened_menus=p1_char_select)
print(screen)
ready_players = 0
player_one_HANDLER.attach(menu=p1_char_select, name="player one")
banned_list = []

while(player_select_loop and running):
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    screen.game_state = "char_select_loop"

    if ready_players >= player_num:
        player_select_loop = False

    controller_handler.update()
    if controller_handler.is_next_ready():
        print("found next player; player: ", player_num +1)
        if player_num == 1:
            print("player num is 1, now 2; found next player")
            player_num = 2
            player_two_HANDLER = controller_handler.get_next_player()
            player_two_HANDLER.attach(menu=p2_char_select, name='player two')
            screen.apply(next_player=player_two_HANDLER, opened_menus=p2_char_select)
        elif player_num == 2:
            print("player num is 2, now 3; found next player")
            player_num = 3
            player_three_HANDLER = controller_handler.get_next_player()
            player_three_HANDLER.attach(menu=p3_char_select, name='player three')
            screen.apply(next_player=player_three_HANDLER, opened_menus=p3_char_select)
        elif player_num == 3:
            player_num = 4
            player_four_HANDLER = controller_handler.get_next_player()
            player_four_HANDLER.attach(menu=p4_char_select, name="player four")
            screen.apply(next_player=player_four_HANDLER, opened_menus=p4_char_select)
        if player_num > 1:
            try:
                assert (screen.player_index >= player_num), "tried and failed to add next player"
            except AssertionError as error:
                print(error)
                print("screen's player index= ", screen.player_index, "player num= ", player_num)
                print("player handlers in screen: ", screen.ordered_list_of_player_HANDLERS)

    screen.update()
    screen.draw(game_window)
    for each in screen.menus:
        pick = each.is_ready()
        if pick != -1 and pick not in banned_list:
            assert (pick not in banned_list), "invalid pick"
            banned_list.append(pick)
            ready_players += 1
            print("ready_players= ", ready_players, "player_num= ", player_num)
            for every in screen.menus:
                every.ban_book(pick)
                every.next_book()

    for each in screen.ordered_list_of_player_HANDLERS:
        each.update_menu()

    screen.draw(game_window)

    clock.tick(config.fps)
    pygame.display.update()
    pygame.event.pump()
    pygame.time.wait(0)

player_sprites = pygame.sprite.Group()

screen.apply(closed_menus=(p1_char_select, p2_char_select, p3_char_select, p4_char_select))

game_window.fill((0, 0, 0))
import room, player, enemies, spriteling
# scope tomfoolery
plyr = player.multiplayer


DEBUG_dungeon = room.basic_dungeon(game_window)
screen.apply(room=DEBUG_dungeon())


# may replace this with some event driven progging
screen.game_start(plyr, DEBUG_dungeon.get_hub())

while(game_loop and running):
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    screen.game_state = "game_loop"

    screen.update()

    screen.draw(game_window)

    clock.tick(config.fps)
    pygame.event.pump()
    pygame.time.wait(0)
