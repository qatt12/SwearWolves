# dmmmmmmmmmmmmmmmmmdddmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmdddddmmmmmmmmmmmmmmmmmddmmmNN
# dNNNmyyyyyyyyyyyyyyysysyysyssssyssssysysyysyysysyssysyssysysyysysyssysssoooooossssyyyyyyysssssshmmNN
# dNNN//+////++++++++++++++++/+/++/+++++///+/+++++++/+///++++++++++++++++++++++///////++++////////hNNN
# dNNm/++:yoo+/:++:s//o:///o+:y/+:s++//++/yo:s///:o+:yo-++o+/+o++++++++++++++++++++++/////++/+++++hNNN
# hmmm/++:y++/s+oy:y/so/syso+/y+:oo+++s++/y+/so+oss+/s+++so/+so+++++++++++++++++++++++++//++++++++hNNN
# hmmm/+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++hNNN
# hmmm/-```````````````````.-----:://:....................................```````````````````````+hNNN
# hmmm:`                  `----::://.......................................`                     /hNNN
# hmmm:`                  ---:://+:```......................................`                    /hNNN
# hmmm:`                 --:-////-.`.....`...........--..-....-...--........-.``                 /hNMN
# hmmm:`                 :--:///:..-.-..`.............:-.--....-...-:..........-`                /hMMN
# hmmm:`                `:.-://+..:---.........-......-+-.--....--..-/-...-...-:-`               /hMMN
# hmmm:`                ..--:///::+//:-.-....-/--.-..-/+o:.:-....--..-/.`.--...:--               /hMMN
# hmmm:`               `-..-:/+//++s/////::::/:-.-.-/++/-:/-::....-...:/.`./..:./-.              /hMMN
# hmmm:`          .`   `-..-::o//++so//////+++//::/oo+:.``:/:/:--..-...//../..-:./-`             /hMMN
# hmmm:`         .`    ....-::o//osos//////++//+os+/:::/+/..////-----..-+/.+-.-:.:--`    `       /hMMN
# dmmm:`         ..   `/....:-+o/soos////++//+os/:..--```-.``-/++/::::::/s:o---/..`--`  ``.`     /hMMN
# dmmm:`          -...-/-...--:s+o++o////syss+++ydmdhh/.```````-/+oso++//oss/::o:- `.-..`..`     /hMMN
# dmmm:`           ```` -....:-os:.:////ohy+:ymNMMMoh-s.`````````-/o+++o+/ys///+:-    ````       /hMMN
# dmmm:`                 -...--:s``+:+//+y+`.ymsNMNNh ```````````-:+yo++ooyoo::/-.               /hMMN
# dmNm:`                 `-..---s``/:+//+o+```yyosyN: ``````````+mNdsh/::ss+/:./-`               /hMMN
# dNNm:`                  -...-:+/-/////+//.`.-+oos/ ``````````/mMNy//y.+y+//`.:.                /hMMN
# dNNm:`                  -...-+//o+:///++..```````````````````yoddh`ss:yo+:` --                 /hMMN
# dNNm:`                  :..-+///++-:://o-````````````````````sso+`.-.oy+.  .-`                 /hMMN
# mNNN:`                  :.::://++o-:-///+.```````````````-`````.-```//s/. `:`                  /hMMN
# mNNN:`                `-::--///+oo::--////`````.+..````````````````-+/+o+--`                   /hMMN
# mNNN:`            `..-.---:///++++o-:.-////`````+---....:-````````.o//:++/::--.`               /hMMN
# mNNN:`          `....---:////+++/+o---.-////````:/::::::/````````:o/+::-//:::::--`             /hMMN
# mNNN:`        `....-.-:///::++////+/.:..://o/.```.-.---```````-:+/+///:--////:--:-.            /hMMN
# mMMN:`       `...--.://+::+/////////.:..-//o///-`````````.-//s/////++//:-.:+///--:-.           /hMMN
# NMMN:`       ....:-://+-:+///////+//.-..-//+/::://:...:+///+/++//////o//--.-+///.:.-           /hMMN
# NMMN:`       ...--:////.+////////+/-.:..-//+:--:::://:s/////o/++//////o//-..:+//-:.:           /hMMN
# NMMM:`       ...-::////.////////++/.--..-//+-...------://////++++/////o/+:...///-:.-           /hMMN
# NMMM:`       ...-/-://+-///////+o/.--...://+............-//::-:ssysoo+o+/:...///:.-`           /hMMN
# NMMM:`       `...-:-:///-:+osydy-.--...-:/+.`````....````.:s-../mmmmddd//-...+/-.-`            /hMMN
# NMMM:`         `..-:::+hddddmd/.--...--:/o-..``````````..``hy...hmmmmh+/-..-:/...              /hMMN
# NMMM:`           `.-```./sdms-.--...--:/s-````.````````````dm:.-dmmho/:-.--. `.`               /hMMN
# NMMM:`          ``        .+..-....--:+hmh:```````````````:mm:.smmy//----``    ``              /hMMN
# NMMM:`        ``          ...-...--:+ydddmdy/`          .`sd+/yddm//::-```      `.             /hMMN
# NMMM:`       ``           -.:..--:+hdyhhhhhhhs:`         /hyyyyhdds/+-.` .`      :`            /hMMN
# NMMM:`      .`            ---.--:/shhhhhyyyyyyys/.      `yyyyyhhho-://:-.`       :-`           /hMMN
# NMMM:`     .`             -----::: ./syhdhhyyyyyyyo/---:yhhhhhys:`  ``...```     :`-.          /hMMN
# NMMM:`   `-.````          `----::/    .:ssyyhhhhyyhhddddmmdddddyo/-.`   `.----.` `  `.`        /hMMN
# NMMM:`  `/--.`            `./--::/:`   -.`.-:+oydddmNNmmNNNNmmmdddddhs/  `-..`        .`       /hMMN
# NMMM:```:-`           ```.....--:://:-```    .ohdmNNNNNNNNNmmNNmmdddmms   `-.`         `.`     /hMMN
# NMMM:.``         ```.........   `````      `+hddmNmmNNNNNNmNmddddddmmm-    `-.``     `---:     /hMMN
# NMMM/`      `````````........            `/hdddmNmdmNNNNNNmdmdddddmmm+      `:.``  `-.+//+`    /hMMN
# NMMMy+::::::::::::::::///////::::::::::::oyyyyyhyyyyyyhhhhyyyyyyyyyhs::::::::+//:://:::o++:::::sNMMN
# NMMMMNNNmmmNmmmNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNmmNNNNNNNNNNNmmmmNNNNNNNNNMMMMN
# NMMMMMMdsoshsosyhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmhosdNMMMMMMMMmyoodMMMMMMMMMMMMMN
# NMMMMMy:` ``` ``./dmhdmNNdhddmNNmhhdmmNNmdmNmdmddmddddmmddmNMMmddmy/.``-/ymNNmdmy:` -oNdhdmNNMMMMMMN
# NMMMMMy/-`  ..`  :/-`..-/..-`.-/:.`..-/:..:+:....:..-..-..-/so:.`..:-`   .:+/..-:-  -//.`..-/dMMMMMN
# NMMMMMMN/.  ::`  :` ``  -   `  `.`  .:.    `.   `.   `  `  `:`  `  -.  -  `.    `-  --` ` `-/mMMMMMN
# NMMMMMMN/.  ::`  :  ..  :  `:  .-`   -.  `.::  `::  `-  -` `:` `-  -.  :` `.   .:-  --     `/mMMMMMN
# NMMMMMmo-`  ``  `:  ``  -  `:  `--.  -.  `..:   .-  `-  -`  -`  `  ..  `  `.  `...  .:. `  `/mMMMMMN
# NMMMMMm+-`  .`.:+/-..-..:..-/-.--.`  --....:/-...:..-:..:-.-/-...-.::-...:+:-...-/-.--....-+hMMMMMMN
# NMMMMMMN/.`-/yhmNmdhyhhyhhhhdd+:.``.:ohdhyydmdhyhdhhhhhhhdhhddhyhhyhmdhyhmmddhyyhmdhhddhhhdNNMMMMMMN
# NMMMMMMMdsydNNNNNmmmmmmmmmmmmmdysssydmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmNNNNNNNNNMMMMMN
# NMMMMNNNNNNNNNNNmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmNNNNNNNNNNNMMN

import spriteling, pygame, events
from events import event_maker
from config import fps as sec
import config, random
from collections import deque
from blocks import block
import math

all_books = pygame.image.load(    'Animation\img_books.png').convert()
all_books.set_colorkey(config.default_transparency)

ice_book_img   = all_books.subsurface(( 0,  0), (20, 20))
fire_book_img  = all_books.subsurface(( 0, 20), (20, 20))
acid_book_img  = all_books.subsurface(( 0, 40), (20, 20))
light_book_img = all_books.subsurface(( 0, 60), (20, 20))

leaf_book_img  = all_books.subsurface((20,  0), (20, 20))
elec_book_img  = all_books.subsurface((20, 20), (20, 20))
water_book_img = all_books.subsurface((20, 40), (20, 20))
moon_book_img  = all_books.subsurface((20, 60), (20, 20))

metal_book_img = all_books.subsurface((40,  0), (20, 20))
wind_book_img  = all_books.subsurface((40, 20), (20, 20))
holy_book_img  = all_books.subsurface((40, 40), (20, 20))
dead_book_img  = all_books.subsurface((40, 60), (20, 20))

rock_book_img  = all_books.subsurface((60,  0), (20, 20))
magnet_book_img= all_books.subsurface((60, 20), (20, 20))
DEBUG_book_img = all_books.subsurface((60, 40), (20, 20))
bug_book_img   = all_books.subsurface((60, 60), (20, 20))

bigger_books = pygame.transform.scale2x(all_books)
bb_size = bigger_books.get_rect()
h = bb_size.height
onfr = h/4
w = bb_size.width

big_ice_book_img   = bigger_books.subsurface(( 0, onfr*0), (onfr, onfr))
big_fire_book_img  = bigger_books.subsurface(( 0, onfr*1), (onfr, onfr))
big_acid_book_img  = bigger_books.subsurface(( 0, onfr*2), (onfr, onfr))
big_light_book_img = bigger_books.subsurface(( 0, onfr*3), (onfr, onfr))

big_leaf_book_img = bigger_books.subsurface((onfr*1, onfr*0), (onfr, onfr))
big_elec_book_img  = bigger_books.subsurface((onfr*1, onfr*1), (onfr, onfr))
big_water_book_img = bigger_books.subsurface((onfr*1, onfr*2), (onfr, onfr))
big_moon_book_img  = bigger_books.subsurface((onfr*1, onfr*3), (onfr, onfr))

big_metal_book_img = bigger_books.subsurface((onfr*2, onfr*0), (onfr, onfr))
big_wind_book_img  = bigger_books.subsurface((onfr*2, onfr*1), (onfr, onfr))
big_holy_book_img  = bigger_books.subsurface((onfr*2, onfr*2), (onfr, onfr))
big_dead_book_img  = bigger_books.subsurface((onfr*2, onfr*3), (onfr, onfr))

big_rock_book_img  = bigger_books.subsurface((onfr*3, onfr*0), (onfr, onfr))
big_magnet_book_img= bigger_books.subsurface((onfr*3, onfr*1), (onfr, onfr))
big_DEBUG_book_img = bigger_books.subsurface((onfr*3, onfr*2), (onfr, onfr))
big_bug_book_img   = bigger_books.subsurface((onfr*3, onfr*3), (onfr, onfr))


hit_marker_img = pygame.image.load(      'Animation\img_hit_marker.png').convert()
hit_marker_img.set_colorkey(config.black)

fire_bolt_img   = pygame.image.load(    'Animation\img_fireshot.png').convert()
fire_ball_img   = pygame.image.load(    'Animation\img_fireball.png').convert()
fire_bolt_img.set_colorkey(config.default_transparency)
fire_ball_img.set_colorkey(config.default_transparency)
#############
# 0 # 1 # 2 #
# 3 # 4 # 5 #
# 6 # 7 # 8 #
###*#########
fire_bolt_img_lookup = {
    0: pygame.transform.rotate( fire_ball_img, 90+45),
    1: pygame.transform.rotate( fire_ball_img, 90+45),
    2: pygame.transform.rotate( fire_ball_img, 90+45),
    3: pygame.transform.rotate( fire_ball_img, 90+45),
    4: pygame.transform.rotate( fire_ball_img, 90+45),
    5: fire_ball_img,
    6: pygame.transform.rotate( fire_ball_img, 90+45),
    7: pygame.transform.rotate( fire_ball_img, 90+45),
    8: pygame.transform.rotate( fire_ball_img, 90+45),
}


fire_wave_base_img = pygame.image.load(    'Animation\img_fireball.png').convert()
fire_wave_base_img.set_colorkey(config.default_transparency)
fire_wave_img_set = [pygame.transform.scale(fire_wave_base_img, (x, x)) for x in range(0, 78, 26)]

green_bubbles_img   = pygame.image.load( 'Animation\img_poisonball.png').convert()
green_bubbles_img.set_colorkey(config.default_transparency)
poison_drop_img = pygame.image.load( 'Animation\img_poisoned.png').convert()
green_bubbles_img.set_colorkey(config.default_transparency)

ice_shard_img   = pygame.image.load(    'Animation\img_iceball.png').convert()
ice_shard_img.set_colorkey(config.default_transparency)
ice_beam_img   = pygame.image.load(    'Animation\img_icebeam.png').convert()
ice_beam_img.set_colorkey(config.default_transparency)

# not done
icicle_img = pygame.image.load(    'Animation\img_icespike.png').convert()
icicle_img .set_colorkey(config.default_transparency)
BIG_icicle_img = pygame.transform.scale2x(icicle_img )
glacier_img = pygame.image.load(    'Animation\img_icebeam.png').convert()
glacier_img.set_colorkey(config.default_transparency)

rock_shard_img = pygame.image.load(    'Animation\img_rock.png').convert()
rock_shard_img.set_colorkey(config.default_transparency)

big_ol_rock_img = pygame.image.load(    'Animation\img_b_rock.png').convert()
BIG_big_ol_rock_img = pygame.transform.scale2x(big_ol_rock_img)
BIG_big_ol_rock_img.set_colorkey(config.default_transparency)

bee_img   = pygame.image.load(    'Animation\img_bee.png').convert()
hive_img = pygame.image.load(    'Animation\img_hive.png').convert()
bee_img.set_colorkey(config.default_transparency)
hive_img.set_colorkey(config.default_transparency)

leaf_img = pygame.image.load(    'Animation\img_leaf.png').convert()
leaf_img.set_colorkey(config.default_transparency)

seed_img = pygame.image.load(    'Animation\img_leaf.png').convert()
seed_img.set_colorkey(config.default_transparency)

bullet_img = pygame.image.load(    'Animation\img_neon_bullet.png').convert()
bullet_img.set_colorkey(config.default_transparency)

sun_particle_img = pygame.image.load(    'Animation\img_sunbeam.png').convert()
sun_particle_img.set_colorkey(config.default_transparency)
toxic_spore_img = acid_book_img
small_fire_img = fire_book_img
water_splash_img = ice_book_img

default_reticle =pygame.image.load('projectiles\img_crosshair.png').convert_alpha()

the_mighty_apis_img = pygame.image.load(    'Animation\img_apis.png').convert().set_colorkey(config.default_transparency)


apply_to_players = pygame.sprite.Group()
apply_to_enemies = pygame.sprite.Group()

# need to edit this, replace it with the proper, pygame form of Copy()?
def dupe(base_surf, num=0, is_num=False, **kwargs):
    if 'size' in kwargs:
        ret = pygame.Surface(kwargs['size'])
    else:
        x, y = base_surf.get_width(), base_surf.get_height()
        ret = pygame.Surface((20, 20))
    if is_num:
        pass
    ret.blit(base_surf, (0, 0))
    return ret

#sin_offsets = [math.sin(math.radians(x)) for x in range(0, 360)]

class velocity():
    def __init__(self, x=0, y=0, **kwargs):
        self.x = x
        self.y = y
        mag_x, mag_y = 1, 1
        if 'mag' in kwargs:
            mag_x, mag_y = kwargs['mag'], kwargs['mag']
        elif "var_mag" in kwargs:
            mag_x = (kwargs['var_mag'][0] - kwargs['var_mag'][1]) + random.randint(0, int(2*kwargs['var_mag'][1]))
            mag_y = (kwargs['var_mag'][0] - kwargs['var_mag'][1]) + random.randint(0, int(2 * kwargs['var_mag'][1]))
        if 'dir' in kwargs:
            self.x = mag_x * kwargs['dir'][0]
            self.y = mag_y * kwargs['dir'][1]
        self.p_x = x % 1
        self.t_x = 0.0
        self.p_y = y % 1
        self.t_y = 0.0

    def __call__(self, x=False, y=False, *args, **kwargs):
        if x:
            self.x = x
            self.p_x = x % math.copysign(1, x)
        if y:
            self.y = y
            self.p_y = y % math.copysign(1, y)

        if 'flip' in kwargs:
            if kwargs['flip'][0]:
                self.x = -self.x
            if kwargs['flip'][1]:
                self.y = -self.y

        if 'add_x' in kwargs:
            self.x += kwargs['add_x']
        if 'add_y' in kwargs:
            self.y += kwargs['add_y']

        if 'recalc_x' in kwargs:
            math.copysign(self.x, kwargs['recalc_x'])
            self.x += kwargs['recalc_x']
            self.p_x = self.x % math.copysign(1, kwargs["recalc_x"])
        if 'recalc_y' in kwargs:
            math.copysign(self.y, kwargs['recalc_y'])
            self.y += kwargs['recalc_y']
            self.p_y = self.y % math.copysign(1, kwargs["recalc_y"])

        r_x = self.x
        r_y = self.y
        self.t_x += self.p_x
        self.t_y += self.p_y
        if self.t_x > 1:
            self.t_x -= 1
            r_x += 1
        elif self.t_x < -1:
            self.t_x += 1
            r_x -= 1
        if self.t_y > 1:
            self.t_y -= 1
            r_y += 1
        elif self.t_y < -1:
            self.t_y += 1
            r_y -= 1
        return r_x, r_y

    def stop(self):
        self.x = 0
        self.y = 0
        self.p_x = 0
        self.p_y = 0

    def __getitem__(self, item):
        if item == '0' or item == 0 or item == 'x':
            return self.x
        elif item == '1' or item == 1 or item == 'y':
            return self.y

class hit_marker(spriteling.spriteling):
    def __init__(self, location):
        super().__init__(image=hit_marker_img, loc=location)
        self.layer = config.impact_layer
        self.timer = sec/4

    def update(self, *args, **kwargs):
        self.timer -= 1
        if self.timer <= 0:
            self.kill()

    def __call__(self, new_loc, *args, **kwargs):
        pass
        # self.rect.center = new_loc

        # self.timer = sec/2


# the arrangement of spells (or more generally, all attacks) goes like this: each player character gets a spell book,
# and each spell book has a particular pre-defined list of spells attached to it (one spell for each category). To
# unlock new spells, the 'add_spell' method is called from the spell book, and a string referencing the spell to be
# added is passed in. the spell_book, which already has all possible spells defined and listed in an internal
# dictionary, uses the passed in string as the key to look up which spell it should add.
# mechanically, the book just keeps track of the spells (which are unlocked and which is selected) and makes sure the
# spell's image appears in the right place (that it follows the player character around). the spell is a (potentially
# animated) sprite that follows the pc around and handles the firing of missiles/projectiles

# spell book is a handler/container class meant to hold a bunch of spells
class spell_book(spriteling.spriteling):

    def __init__(self, level=1, **kwargs):
        super().__init__(image=DEBUG_book_img)
        event_maker.make_entry('log', 'spellbook', 'A new spell book has been made; this is the base constructor', 'spells', True, True,
                               'spellbook', 'spells', 'magic', 'base',
                               obj_src=spell_book, loc_src='spellbook abstract base class', inst_src=self)
        # contains an instance of/ constructor for all unlocked spells
        self.spells = []
        self.spell_key = {0: spell}
        self.level_costs = {0: 1000, 1: 2000}
        self.level = level
        self.index = 0
        self.length = 1

        self.reticle_constr = None
        self.my_player_HANDLER = None
        self.special_effects = []
        self.special = None

        # this is maintained so that spells not currently selected can still be updated (mostly fo spells that need to
        # cool down; their cooldowns don't reset upon selecting a new spell
        self.other_spells = pygame.sprite.Group()
        self.active_spell = pygame.sprite.GroupSingle()
        self.layer = config.overlayer

    def get_active_spell(self):
        return (self.index, self.spells[self.index])

    def set_my_player_HANDLER(self, handler):
        self.my_player_HANDLER = handler
        self.my_player_HANDLER.apply_to_player(self.special_effects)

    def update(self, loc, *args, **kwargs):
        # the cycle and select spell are for controllers and keyboards, res. Keyboards can choose a spell based on the
        # number keys, controllers can cycle between them

        if 'fire' in kwargs:
            for lonely in self.active_spell:
                lonely.update(True, loc, kwargs['fire'][0], kwargs['fire'][1], kwargs['direction'],
                              **kwargs)
        else:
            # the 'active' param must be set to false here. To tell the spell not to expect input??
            # I know that its essential to keep charged spells working
            self.active_spell.update(False, loc, 0, 0, (0, 0))
        self.other_spells.update(False, loc, 0, 0, (0, 0))

    def level_up(self):
        pass

    def select_spell(self, **kwargs):
        if 'cycle_spell' in kwargs:
            if kwargs['cycle_spell'] == 'next':
                self.index += 1
                if self.index >= self.length:
                    self.index = 0
            elif kwargs['cycle_spell'] == 'prev':
                self.index -= 1
                if self.index < 0:
                    self.index = self.length - 1
            self.other_spells.add(self.active_spell)
            self.active_spell.add(self.spells[self.index])
            self.other_spells.remove(self.active_spell)
            event_maker.make_entry('trace', 'changing spells', '', 'spells', False, False,
                                   'misc', 'extra', 'magic', 'spellbook',
                                   active_spell=self.spells[self.index],
                                   obj_src='spellbook', inst_src=self)
        if 'select_spell' in kwargs:
            if kwargs['select spell'] < self.length and kwargs['select_spell'] > 0:
                self.index = kwargs['select spell'] -1
            self.other_spells.add(self.active_spell)
            self.active_spell.add(self.spells[self.index])
            self.other_spells.remove(self.active_spell)
            event_maker.make_entry('trace', 'changing spells', '', 'spells', False, False,
                                   'misc', 'extra', 'magic', 'spellbook',
                                   active_spell=self.spells[self.index],
                                   obj_src='spellbook', inst_src=self)
        return self.spells[self.index]

    def pop_spells(self, reticle_constr):
        self.reticle_constr = reticle_constr
        self.length = self.level
        if self.length == 1:
            self.spells.append(self.spell_key[0](reticle_constr=reticle_constr, caster=self.my_player_HANDLER))
            self.other_spells.add(self.spells[0])
        else:
            for x in range(0, self.level):
                self.spells.append(self.spell_key[x](reticle_constr=reticle_constr, caster=self.my_player_HANDLER))
                self.other_spells.add(self.spells[x])
        self.active_spell.add(self.spells[self.index])
        self.other_spells.remove(self.active_spell)

    def draw(self, disp, draw_boxes=False):
        for each in self.active_spell:
            each.draw(disp, draw_boxes)

# each attack/spell has two components: the spell and the missile. the spell is basically just an image that follows the
# player around, while the missile is created and propelled by the spell.
# 'attack' and 'spell' are nearly interchangeable, but since 'spell' technically/internally refers to a specific object
# w/i the game files, I will shy away from using it unless I'm talking about that particular object

# ancestral class for missiles (things that fly out and hit other things)
# missiles are fired (begin moving) immediately after begin created
class missile(spriteling.spriteling):
    def __init__(self, img, loc, vel, *args, **kwargs):

        error_msg = events.entry('error', "type error", "the types of the input params sent up to missile.__init__() "
                                                        "don't match", 'spells', obj_src='missile', got_kwargs=kwargs,)
        #try:
        #    assert (isinstance(img, pygame.Surface)), "img is not a surface"
        #except AssertionError as more_desc:
        #    error_msg.modify(ext_desc=str(more_desc), img_type=str(type(img)))
        #    event_maker.send_entry(error_msg)
        #try:
        #    assert (isinstance(loc, tuple)), "loc is not a tuple"
        #except AssertionError as more_desc:
        #    error_msg.modify(ext_desc=str(more_desc), loc_type=str(type(loc)))
        #    event_maker.send_entry(error_msg)
        #try:
        #    assert (len(loc) == 2), "loc is of improper length"
        #except AssertionError as more_desc:
        #    error_msg.modify(ext_desc=str(more_desc), loc_contents=loc)
        #    event_maker.send_entry(error_msg)
        #if isinstance(loc, tuple):
        #    super().__init__(image=img, loc=loc)

        super().__init__(image=img, loc=loc.center)

        #try:
        #    assert ('caster' in kwargs), "cannot find caster kwarg"
        #except AssertionError as more_desc:
        #    error_msg.modify(new_desc=str(more_desc), got_kwargs=kwargs)
        #    event_maker.send_entry(error_msg)
#
        #try:
        #    assert ('missile_name' in kwargs), "cannot find a missile name"
        #except AssertionError as more_desc:
        #    error_msg.modify(new_desc=str(more_desc), got_kwargs=kwargs)
        #    event_maker.send_entry(error_msg)

        self.missile_name = kwargs['missile_name']
        self.my_caster = kwargs['caster']
        if 'time_limit' in kwargs:
            self.time_limit = kwargs['time_limit']
        else:
            self.time_limit = 10*sec
        if isinstance(vel, tuple):
            self.velocity = velocity(*vel)
        elif isinstance(vel, velocity):
            self.velocity = vel
        else:
            self.velocity = velocity()
        self.effects = []
        for each in args:
            self.effects.append(each)
        self.curr_hp = 1
        self.dmg = 100
        self.elem_type = 'magic'
        self.layer = config.missile_layer

        if 'damage' in kwargs:
            self.dmg = kwargs['damage']
        if "elem" in kwargs:
            self.elem_type = kwargs['elem']
        if 'hp' in kwargs:
            self.curr_hp = kwargs['hp']

        if 'dispersion' in kwargs:
            temp = pygame.rect.Rect((0, 0), (kwargs['dispersion'], kwargs['dispersion']))
            temp.clamp_ip(self.rect)
            self.rect.centerx = temp.left
            self.rect.centery = temp.top
            self.rect.move_ip(random.randint(0, kwargs['dispersion']), random.randint(0, kwargs['dispersion']))
        if 'spread' in kwargs:
            sign = random.randint(0, 4)
            devtn = random.random()
            if sign % 2 == 0:
                devtn *= -1
            devtn *= kwargs['spread']
            if self.velocity[0] != 0:
                self.velocity(recalc_y=devtn/6)
            if self.velocity[1] != 0:
                sign = random.randint(0, 4)
                devtn = random.random()
                if sign % 2 == 0:
                    devtn *= -1
                devtn *= kwargs['spread']
                self.velocity(recalc_x=devtn/6)

        if 'alt_impact' in kwargs:
            self.impact = kwargs['alt_impact']
        else:
            self.impact = hit_marker

    def react(self, to):
        self.time_limit = 20

    def update(self, *args, **kwargs):
        self.time_limit -= 1
        if self.curr_hp <= 0:
            self.kill()
        if self.time_limit <= 0:
            self.kill()
        self.move()
        self.hitbox.update()

    def check_collide(self, target):
        if isinstance(target, block):
            return target.hitbox.rect.collidepoint(self.rect.center)
        else:
            return super().check_collide(target)

    def move(self, force_apply=False, **kwargs):
        self.rect.move_ip(self.velocity())

    def __call__(self, victim, *args, **kwargs):
        if victim.damage(self.elem_type, self.dmg*self.curr_hp):
            victim.apply(*self.effects)
            self.curr_hp -= 1
            self.my_caster.add(impact=self.impact(self.rect.center))
            return True
        return False

class seeker(missile):
    def __init__(self, partner, accel, offset, orbital_rank, img, loc, vel, *args, **kwargs):
        #error_msg = events.entry('error', "type error", "the types of the input params sent up to missile.__init__() "
        #                                                "don't match", 'spells', obj_src='missile', got_kwargs=kwargs, )
        #try:
        #    assert (isinstance(img, pygame.Surface)), "img is not a surface"
        #except AssertionError as more_desc:
        #    error_msg.modify(ext_desc=str(more_desc), img_type=str(type(img)))
        #    event_maker.send_entry(error_msg)
        #try:
        #    assert (isinstance(loc, tuple)), "loc is not a tuple"
        #except AssertionError as more_desc:
        #    error_msg.modify(ext_desc=str(more_desc), loc_type=str(type(loc)))
        #    event_maker.send_entry(error_msg)
        #try:
        #    assert (len(loc) == 2), "loc is of improper length"
        #except AssertionError as more_desc:
        #    error_msg.modify(ext_desc=str(more_desc), loc_contents=loc)
        #    event_maker.send_entry(error_msg)

        super().__init__(img, loc, vel, *args, **kwargs)
        self.pair = partner
        self.accel = accel
        if orbital_rank != 0:
            self.normal = False
            if orbital_rank % 2 == 0:
                sign = -1
            else:
                sign = 1
            event_maker.make_entry("trace", "helix checking", "", "spells", False, False)
            if self.velocity[1] != 0:
                self.rect.centerx = (self.pair.rect.centerx + sign*offset*self.accel)
            if self.velocity[0] != 0:
                self.rect.centery = (self.pair.rect.centery + sign*offset*self.accel)
        else:
            self.normal = True
        if 'max_vel' in kwargs:
            self.top_speed = kwargs['max_vel']
        else:
            self.top_speed = 1000000000
        if 'min_distance' in kwargs:
            self.min_distance = kwargs['min_distance']
        else:
            self.min_distance = 0


    # might cut the extra and gates
    def update(self, *args, **kwargs):
        if not self.normal:
            if abs(self.rect.centerx - self.pair.rect.centerx) > self.min_distance:
                if self.rect.centerx > self.pair.rect.centerx and abs(self.velocity[0]) < self.top_speed:
                    self.velocity(add_x=-self.accel)
                elif self.rect.centerx < self.pair.rect.centerx and abs(self.velocity[0]) < self.top_speed:
                    self.velocity(add_x=self.accel)
            if abs(self.rect.centery - self.pair.rect.centery) > self.min_distance:
                if self.rect.centery > self.pair.rect.centery and abs(self.velocity[1]) < self.top_speed:
                    self.velocity(add_y=-self.accel)
                elif self.rect.centery < self.pair.rect.centery and abs(self.velocity[1]) < self.top_speed:
                    self.velocity(add_y=self.accel)
        super().update(*args, **kwargs)

    def set_partner(self, new_partner):
        self.pair = new_partner

class boomerang(seeker):
    def __init__(self, num_strikes, partner, accel, offset, orbital_rank, img, loc, vel, *args, **kwargs):
        super().__init__(partner, accel, offset, orbital_rank, img, loc, vel, *args, **kwargs)
        self.made_it_back = False
        self.struck_target = num_strikes

    def react(self, to):
        if self.struck_target > 0:
            self.struck_target -= 1
        else:
            self.set_partner(self.my_caster.player)
        super().react(to)

    def __call__(self, victim, *args, **kwargs):
        super().__call__(victim)
        if self.struck_target > 0:
            self.struck_target -= 1
        else:
            self.set_partner(self.my_caster.player)


class strict_orbit(missile):
    def __init__(self, subject, radius, img, loc, vel, *args, **kwargs):
        super().__init__(img, loc, vel, *args, **kwargs)
        self.radius = radius
        self.rect.center = subject.rect.center
        self.rect.centerx = subject.rect.centerx + radius
        self.subject = subject
        self.velocity = velocity(0, 0)
        self.quadrant = 1
        self.angle = 0
        if "angular_speed" in kwargs:
            self.angular_speed = kwargs["angular_speed"]
        else:
            self.angular_speed = 3

        # needs more testing
        if "at_angles" in kwargs:
            self.angle_triggers = kwargs['at_angles']

    def update(self, *args, **kwargs):
        super().update(*args, **kwargs)
        self.angle += self.angular_speed
        if self.angle > 360:
            self.angle = 0
        locus = self.subject.rect.center
        x_pos = locus[0] + math.cos(math.radians(self.angle)) * self.radius
        y_pos = locus[1] + math.sin(math.radians(self.angle)) * self.radius
        self.rect.center = x_pos, y_pos




class swirl(strict_orbit):
    def __init__(self, radius_growth, subject, radius, img, loc, vel, *args, **kwargs):
        super().__init__(subject, radius, img, loc, vel, *args, **kwargs)
        self.radius_growth = radius_growth

    def update(self, *args, **kwargs):
        self.radius += self.radius_growth
        super().update(*args, **kwargs)


class aura(missile):
    def __init__(self, follow, duration, radius, loc, vel=(0, 0), *args, **kwargs):
        img = pygame.Surface((2*radius, 2*radius))
        img.set_colorkey(config.black)
        pygame.draw.circle(img, config.yellow, img.get_rect().center, radius)

        super().__init__(img, loc, (0, 0), *args, **kwargs, time_limit=duration)
        self.follow = follow
        self.subject = self.my_caster
        self.radius = radius
        self.layer = config.floor_cos

    def update(self, *args, **kwargs):
        super().update(*args, **kwargs)
        if self.follow:
            self.rect.center = self.subject.rect.center
            self.hitbox.update()

    def __call__(self, target, *args, **kwargs):
        if events.dist(self, target) <= self.radius:
            super().__call__(target, *args, **kwargs)

    def check_collide(self, target):
        if isinstance(target, block):
            return False
        return events.dist(self, target) <= self.radius


class size_function():
    def __init__(self, start, asc, peak, desc,):
        self.size = start
        self.ascending = asc
        self.peak = peak
        self.descending = desc

    def __call__(self, stage):
        if stage == 0:
            return self.size
        elif stage <= self.peak:
            return self.ascending(stage)
        else:
            return self.descending(stage)


class trail(spriteling.spriteling):
    pass

class opaque_trail(trail):
    pass


class trigger():
    def __call__(self, prev, now):
        return False

    def get_data(self):
        return {'power': 1}

    def restore(self):
        return False

class semi(trigger):
    def __call__(self, prev, now):
        return now and not prev

class semi_release(trigger):
    def __call__(self, prev, now):
        return prev and not now

class hold(trigger):
    def __call__(self, prev, now):
        return now and prev

class press(trigger):
    def __call__(self, prev, now):
        return now

class release(trigger):
    def __call__(self, prev, now):
        return not now

class cast_per_room(trigger):
    def __init__(self, num_casts):
        self.max_casts = num_casts
        self.casts = num_casts
        event_maker.set_tracker(str(events.room_event)+str(events.next_room), self.restore)

    def restore(self):
        self.casts = self.max_casts

    def __call__(self, key, dummy=False):
        if key and self.casts >= 0:
            self.casts -= 1
        return self.casts >= 0 and key


class cast_per_run(trigger):
    def __init__(self, num_casts):
        self.max_casts = num_casts
        self.casts = num_casts
        event_maker.set_tracker(str(events.room_event)+str(events.to_hub), self.restore)

    def restore(self):
        self.casts = self.max_casts

    def __call__(self, key, dummy=False):
        if key and self.casts >= 0:
            self.casts -= 1
        return self.casts>=0 and key

class cap(trigger):
    def __init__(self, num_uses):
        self.max_uses = num_uses
        self.uses = 0

    def restore(self):
        self.uses = 0

    def __call__(self, key, reset=False):
        if reset:
            self.uses = 0
            return False
        elif key and self.uses <= self.max_uses:
            self.uses += 1
        return key and self.uses <= self.max_uses

# charge_up spells need to be charged by holding the fire button until they are sufficiently charged
# every frame in which the fire button is held (it determines if the button is held by checking the current and previous
# frame's data) the spell gains 1 charge.
class charged_gate(trigger):
    def __init__(self, max):
        self.charge_time = max * sec
        self.charge = 0

    def __call__(self, prev, now):
        if now and prev:
            self.charge += 1
            return False
        elif now and not prev:
            self.charge = 1
        elif prev and not now:
            return self.charge >= self.charge_time
        else:
            self.charge = 0
        return self.charge >= self.charge_time


class simple_multicharge_gate(trigger):
    def __init__(self, size, step, delay=10):
        self.thresholds = [x for x in range(step, step*size, step)]
        self.drop_rate = step
        self.charge = 0
        self.stages = 0
        self.delay = delay
        self.timer = 0

    def __call__(self, prev, now):
        if now and prev:
            self.charge += 1
            if self.charge >= self.thresholds[self.stages]:
                self.stages = min(len(self.thresholds)-1, self.stages+1)
        elif self.timer > 0:
            self.timer -=1
            return False
        elif self.stages > 0:
            self.charge = 0
            self.stages -= 1
            self.timer = self.delay
            return True
        return False


class over_heated(trigger):
    def __init__(self, max_heat, heat_per_missile):
        self.over_heated = False
        self.max_temp = max_heat
        self.buildup = heat_per_missile
        self.temp = 0

    def __call__(self, prev, now):
        if not self.over_heated and now and not prev:
            self.temp += self.buildup
            self.over_heated = self.temp > self.max_temp
            return True
        elif self.temp > 0:
            self.temp -= 1
            return False
        else:
            self.over_heated = False
        return False


class cooled(trigger):
    def __init__(self, cooldown_time):
        self.cooldown_time = cooldown_time
        self.heat = 0

    def __call__(self, prev, now):
        if self.heat > 0:
            self.heat -= 1

            print(self.heat)

            return False
        elif now:
            print("cooled is firing")
            self.heat = self.cooldown_time
            return True
        return False

class reset_gate(trigger):
    def __init__(self, charge_to):
        self.charge_time = charge_to
        self.charge = 0

    def __call__(self, prev, now):
        if now:
            self.charge += 1
            if self.charge >= self.charge_time:
                self.charge = 0
                return True
            else:
                return False
        else:
            self.charge = 0
            return False


class wind_up(trigger):
    def __init__(self, time_drop, delay_at_start, delay_at_full):
        self.drop = time_drop
        self.min_delay = delay_at_full
        self.max_delay = delay_at_start
        self.charge = 0
        self.curr_delay = delay_at_start

    def __call__(self, prev, now):
        if prev and now:
            if self.charge >= self.curr_delay:
                self.charge = 0
                self.curr_delay = max(self.min_delay, self.curr_delay - self.drop)
                return True
            self.charge += 1
        else:
            self.charge = 0
            self.curr_delay = self.max_delay
        return False

class chained_trigger(trigger):
    def __init__(self, *args):
        self.gates = []
        for each in args:
            self.gates.append(each)

    def __call__(self, prev, now):
        ret = True
        for each in self.gates:
            ret = ret and each(prev, now)
        return ret

# can handle triggers that only depend on internal state, and triggers that depend on external input
class complex_trigger(trigger):
    def __init__(self, check_first, check_last):
        self.first = check_first
        self.last = check_last

    def __call__(self, prev, now):
        ret = True
        for each in self.first:
            ret = ret and each(prev, now)
        for every in self.last:
            ret = ret and every()
        return ret

class auto_cooled(trigger):
    def __init__(self, cool_down):
        self.cool_down_time = cool_down
        self.timer = 0

    def __call__(self, prev, now):
        if self.timer <= 0:
            self.timer = self.cool_down_time
            return True
        self.timer -= 1
        return False

class gated_trigger(trigger):
    def __init__(self, on, check, latch=trigger()):
        self.check = check
        self.on = on
        self.latch = latch

    def __call__(self, prev, now):
        return self.check(self.on(prev, now), self.latch(prev, now))

    def restore(self):
        self.check.restore()
        self.on.restore()


class trailing_gate(trigger):
    def __init__(self, on, check, trail, latch=trigger()):
        self.check = check
        self.on = on
        self.latch = latch
        self.locked = False
        self.trail = trail

    def __call__(self, prev, now):
        if self.locked:
            self.locked = not self.trail(prev, self.locked)
            return False
        else:
            self.locked = self.latch(prev, now)
            return self.check(self.on(prev, now), self.locked)



class half_double_charge(trigger):
    def __init__(self, start_gate, max_gate, charge_rate=1):
        self.min_thresh = start_gate
        self.max_thresh = max_gate
        self.charge_rate = charge_rate
        self.charge = 0

    def __call__(self, prev, now):
        if now and prev:
            self.charge += 1
            return False
        elif now and not prev:
            self.charge = 1
        elif prev and not now:
            return self.charge >= self.min_thresh
        else:
            self.charge = 0
        return self.charge >= self.min_thresh

    def get_data(self):
        midpt = (self.min_thresh + self.max_thresh)/2
        return self.charge/midpt


# spells themselves don't do much, except for creating and launching missiles
# by default, spells are semi-automatic, meaning the fire key has to be released in between shots
class spell(spriteling.spriteling):
    def __init__(self, projectile, img, **kwargs):

        print("in spell constr")

        super().__init__(image=img)

        try:
            assert ('caster' in kwargs), "ERROR: cannot find caster key"
        except AssertionError:
            event_maker.make_entry('error', 'Caster kwarg not passed', "", 'spells', True, True,
                                   got_kwargs=kwargs)

        # this is to be initialized just before its time to fire
        self.projectile = projectile
        self.my_caster = kwargs['caster']
        if 'type_name' in kwargs:
            self.type_name = kwargs['type_name']
        else:
            self.type_name = 'basic spell'
        if 'spell_name' in kwargs:
            self.spell_name = kwargs['spell_name']
        else:
            self.spell_name = "I should have a name"

        if "trigger_method" in kwargs:
            self.my_trigger = kwargs["trigger_method"]
        else:
            self.my_trigger = semi()

        self.layer = self.my_caster.spell_layer
        if 'recoil' in kwargs:
            self.recoil_growth = kwargs['recoil']
        else:
            self.recoil_growth = 1
        self.recoil = 0

    # the update method controls most if not all of a spell's behavior, and is (I think) the only method of spell called
    # from outside the class. the first param dictates if the spell is active (important for all spells to know if they
    # should be trying to cast, but especially for cooldown, charged, and targeted spells. cooldoown and charged spells
    # depend on internally tracked timers that are evaluated on update, so cooldown spells need to be able to cool, and
    # charged spells need to know to reset their charge when inactive
    def update(self, active, loc, prev, now, *args, **kwargs):
        super().update(*args, **kwargs)
        if self.recoil > 0:
            self.recoil -= 1
        if active:
            self.rect.center = loc
            if self.my_trigger(prev, now) and 'missile_layer' in kwargs:
                kwargs['missile_layer'].add(self.cast(kwargs['direction']))

    # on update, an active spell attempts to cast its projectile. for most spells, this involves tracking the state of
    # the fire button and "AND"ing it to some other condition. for basic spells, this is the (negation of the) state of
    # the fire button on the previous frame (the fire button must be released in between shots).
    # the direction param is a tuple of the form (x, y) where x and y are -1, 0, or 1. these are multiplied by the
    # respective velocity multipliers to determine in which direction the spell's projectile will travel
    def cast(self, direction):
        self.recoil += self.recoil_growth
        return self.projectile(direction, self.rect, spread=self.recoil, caster=self.my_caster)

    def __str__(self):
        return str(self.type_name + ' ' + self.spell_name)



class alt_fire(spell):
    def __init__(self, alt_projectile, alt_trigger, projectile, img, **kwargs):
        super().__init__(projectile, img, **kwargs)
        self.secondary_fire = alt_projectile
        self.secondary_trigger = alt_trigger

    def update(self, active, loc, prev, now, *args, **kwargs):
        super().update(active, loc, prev, now, *args, **kwargs)
        if active:
            if 'missile_layer' in kwargs and self.secondary_trigger(prev, now):
                kwargs['missile_layer'].add(self.alt_cast(kwargs['direction']))

    def alt_cast(self, direction):
        return self.secondary_fire(direction, self.rect,
                            spread=self.recoil, caster=self.my_caster)


class remote_spell(alt_fire):
    def __init__(self, alt_projectile, alt_trigger, projectile, img, **kwargs):
        super().__init__(alt_projectile, alt_trigger, projectile, img, **kwargs)
        self.monitor = deque([])

    def cast(self, direction):
        self.monitor.append(self.projectile(direction, self.rect, caster=self.my_caster, spread=self.recoil))
        return self.monitor

    def alt_cast(self, direction):
        ret = pygame.sprite.Group()
        while len(self.monitor) > 0:
            ret.add(self.secondary_fire(direction, self.monitor.pop(), caster=self.my_caster))
        return ret



class wave_caster(spell):
    def __init__(self, base_img, desc, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.img_set = make_img_seq(base_img, desc, **kwargs)

    def cast(self, direction):
        self.recoil += self.recoil_growth
        return self.projectile(self.img_set, direction, self.rect, caster=self.my_caster, recoil=self.recoil)

def make_img_seq(base_img, desc=True, **kwargs):
        if "scaled" in kwargs:
            times = kwargs['scaled'][0]
            by = kwargs['scaled'][1]
            img_set = [pygame.transform.scale(base_img, (x, x)) for x in
                            range(by, times*by, by)]
        elif 'stretched' in kwargs:
            x_t = kwargs['stretched'][0]
            y_t = kwargs['stretched'][1]
            times =  kwargs['stretched'][2]
            img_set = [pygame.transform.scale(base_img, (x_t*s, y_t*s)) for s in
                       range(0, times)]
        elif 'sliced' in kwargs:
            amt = kwargs['sliced']
            img_set = [base_img.subsurface((0, 0), (base_img.get_rect().width, x)) for x in
                            range(amt, base_img.get_rect().height, amt)]
        if desc:
            for each in reversed(img_set):
                img_set.append(each)
        return img_set

class air_wave(missile):
    def __init__(self, img_set, stage, loc, vel, *args, **kwargs):
        super().__init__(img_set[0], loc, vel, *args, **kwargs)
        self.img_set = img_set
        self.rects = [r.get_rect() for r in self.img_set]
        self.stage = stage
        if "stage_delay" in kwargs:
            self.stage_delay = kwargs['stage_delay']
        else:
            self.stage_delay = 10
        self.timer = 0

    def update(self, *args, **kwargs):
        self.timer += 1
        if self.timer >= self.stage_delay:
            self.timer = 0
            self.stage += 1
            if self.stage >= len(self.img_set):
                self.stage = 0
            self.image = self.img_set[self.stage]
            center = self.rect.center
            self.rect = self.rects[self.stage]
            self.rect.center = center
        super().update(*args, **kwargs)


class ground_wave_caster(wave_caster):
    def __init__(self, base_img, alt_fire, alt_trigger, projectile, img, **kwargs):
        wave_caster.__init__(self, base_img, projectile, img, **kwargs)
        self.monitor = deque([])
        self.secondary_fire = alt_fire
        self.secondary_trigger = alt_trigger

    def cast(self, direction):
        self.monitor.append(self.projectile(direction, self.rect, caster=self.my_caster))

    def alt_cast(self, direction):
        ret = pygame.sprite.Group()
        while len(self.monitor) > 0:
            ret.add(self.secondary_fire(direction, self.monitor.pop().rect, caster=self.my_caster))
        return ret


class ground_wave(missile):
    def __init__(self, img_set, stage, loc, vel, *args, **kwargs):
        super().__init__(img_set[0], loc, vel, *args, **kwargs)
        self.img_set = img_set
        self.max_index = len(self.img_set)/2
        self.rects = [r.get_rect() for r in self.img_set]
        self.stage = stage
        self.active = False
        if 'start_delay' in kwargs:
            self.start_delay = kwargs['start_delay']
        else:
            self.start_delay = sec
        if "stage_delay" in kwargs:
            self.stage_delay = kwargs['stage_delay']
        else:
            self.stage_delay = 30
        self.timer = 0
        if "start_img" in kwargs:
            self.image = kwargs['start_img']
        if 'delay_drop' in kwargs:
            self.delay_drop = kwargs['delay_drop']
        else:
            self.delay_drop = 0
        if 'drop_dist' in kwargs:
            self.rect.move_ip(0, -kwargs['drop_dist'])
        if 'recoil' in kwargs:
            self.max_index = min(len(self.img_set), self.max_index + kwargs['recoil'])

    def update(self, *args, **kwargs):
        self.timer += 1
        if self.active:
            if self.timer >= self.stage_delay:
                self.timer = 0
                self.stage += 1
                self.stage_delay -= self.delay_drop
                if self.stage > self.max_index-1:
                    self.kill()
                else:
                    self.image = self.img_set[self.stage]
                    old_rect = self.rect
                    self.rect = self.rects[self.stage]
                    self.rect.center = old_rect.center
                    self.rect.bottom = old_rect.bottom
        elif self.timer >= self.start_delay:
            self.active = True
        super().update(*args, **kwargs)


class beam(spell):
    def cast(self, direction):
        first = self.projectile(1, None, self.rect, caster=self.my_caster)
        ret = pygame.sprite.Group(first)
        # tricky math time
        dist_per_seg_x = first.rect.width / 2
        dist_per_seg_y = first.rect.height / 2
        if direction[1] == 0:  # if there is no y velocity to worry about, we can just forget it and work with x
            num_segments_to_cross_screen = int(config.screen_width / first.rect.width * 2 ) # the *2 is to account for half
            # overlap

        else:           # the screen is always shorter than it is tall, so if theres any y velocity, we can go with that
            num_segments_to_cross_screen = int(config.screen_height / first.rect.height)

        for x in range(0, num_segments_to_cross_screen):
            first = self.projectile(x+sec/2, first, pygame.rect.Rect((first.rect.centerx+(dist_per_seg_x*direction[0]),
                                                first.rect.centery+(dist_per_seg_y*direction[1])), (3, 3)),
                                    caster=self.my_caster)
            ret.add(first)
        return ret

class beam_particle(missile):
    def __init__(self, timer, prev, img, loc, **kwargs):
        super().__init__(img, loc, velocity(), **kwargs)
        self.next = None
        self.time_limit = timer
        if prev is not None:
            prev.set_next(self)

    def react(self, to):
        if self.next is None:
            self.kill()
        elif isinstance(to, block):
            self.next.react(to)
            self.next.kill()
        else:
            super().react(to)

    def set_next(self, newb):
        self.next = newb

class storm(spell):
    pass

class obstacle(spell):
    pass

##########################
# targeted spells are fukkin nuts. I'll come back to them


# note that the target spell has a different version of the cast method that takes three params instead of two. Thus it
# will only work with missiles specifically made to accept three params in the their constructors
class target(spell):
    def __init__(self, dist, seeks, *args, **kwargs):
        super().__init__(*args, **kwargs, type_name='target')
        self.max_range = dist
        self.chosen_target = None
        self.seeking = seeks
        self.reticle = kwargs['reticle_constr']()

    def update(self, active, loc, prev, now, *args, **kwargs):
        if active:
            message = events.entry("trace", "target spell", 'tracking the progress of the target spell', 'spells',
                                   'old',
                                   seeking=self.seeking, inst_src=self)
            has_layer = 'missile_layer' in kwargs
            message.modify(has_layer=has_layer)
            self.rect.center = loc
            if has_layer:
                # if assess_targets returns True, it means there are valid targets for this spell, and the reticle must
                # be placed in the missile layer
                if self.seeking in kwargs:
                    message.modify(found_targets=kwargs[self.seeking])
                    if self.assess_targets(kwargs[self.seeking], cycle=kwargs['targ_lock']):
                        message.modify(chosen_target=self.chosen_target)
                        kwargs['missile_layer'].add(self.reticle)
                        self.reticle.update(position=self.chosen_target.rect.center)
                        if self.my_trigger(prev, now) and has_layer:
                            kwargs['missile_layer'].add(self.cast(kwargs['direction']))
                    else:
                        self.reticle.kill()
                # if there are no valid targets, the reticle must be removed from the missile layer
                else:
                    self.reticle.kill()

            event_maker.send_entry(message)
        else:
            self.reticle.kill()

    def assess_targets(self, potential_targets, **kwargs):
        pass

    def cast(self, direction):
        return self.projectile(self.chosen_target, direction, self.rect, caster=self.my_caster)


# dumb target just targets the closest valid spriteling
class dumb_target(target):
    def assess_targets(self, targets, **kwargs):
        message = events.entry("trace", 'assessment of assess_targets', "", "spells",
                               "misc", "logan", "extra", "26",
                               received_targets=targets)
        closest = 1000000000
        self.chosen_target = None
        for each in targets:
            if self.max_range >= events.dist(self, each) < closest:
                self.chosen_target = each
        message.modify(expected_return=bool(self.chosen_target))
        event_maker.send_entry(message)
        return bool(self.chosen_target)

# this one is tricky, because it has to keep the potential targets in an ORDERED group, which is not doable with the
# basic group.
# this current version is.... not exactly what I was going for at first, but it is serviceable.
class ordered_target(target):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.possible_targets = deque([])

    def assess_targets(self, targets, **kwargs):
        message = events.entry("trace", 'assessment of assess_targets', "", "spells",
                               "misc", "logan", "extra", "26",
                               received_targets=targets, received_kwargs=kwargs)
        if bool(targets):
            message.modify(new_desc="bool(targets) has returned true")
            if len(self.possible_targets) == 0:
                message.modify(ext_desc="; but apparently there are no valid targets in the spell itself")
                for each in targets:
                    self.possible_targets.append(each)
                    message.modify(ext_desc="; have added the entities from targets",
                                   possible_targets=self.possible_targets)
            if self.chosen_target is None or kwargs['cycle'] == 1:
                self.chosen_target = self.possible_targets.pop()
                self.possible_targets.appendleft(self.chosen_target)
            elif kwargs['cycle'] == -1:
                self.chosen_target = self.possible_targets.popleft()
                self.possible_targets.append(self.chosen_target)

        else:
            message.modify(new_desc="we have not received any targets")
            self.possible_targets.clear()
            self.chosen_target = None
        message.modify(expected_return=bool(self.chosen_target))
        event_maker.send_entry(message)
        return bool(self.chosen_target)


###############################################
class swarm():
    def cast(self, direction):
        return self.projectile(self.chosen_target, 1, self.rect, direction, caster=self.my_caster)

class self_target(target):
    def assess_targets(self, *args, **kwargs):
        self.chosen_target = args[0]
        return True

class guided_swarm(ordered_target):
    def __init__(self, dist, seeks, *args, **kwargs):
        super().__init__(dist, seeks, *args, **kwargs)
        self.swarm = pygame.sprite.Group()

##############################################

class helix(spell):
    def cast(self, direction):
        first = self.projectile(None,   0, self.rect, direction, caster=self.my_caster)
        second = self.projectile(first, 1, self.rect, direction, caster=self.my_caster)
        third = self.projectile(first, -1, self.rect, direction, caster=self.my_caster)
        return second, first, third


sin_offsets = [math.sin(math.radians(x)) for x in range(0, config.screen_width)]
cos_offsets = [math.cos(math.radians(x)) for x in range(0, config.screen_width)]

#     def __init__(self, partner, accel, offset, orbital_rank, img, loc, vel, *args, **kwargs):

class threelix(missile):
    def __init__(self, partner, amp, orbital_rank, img, loc, vel, *args, **kwargs):
        super().__init__(img, loc, vel, *args, **kwargs)
        self.timer = 0
        self.partner = partner
        self.amp = amp
        self.x_off = sin_offsets.copy()
        self.y_off = cos_offsets.copy()
        self.normal = orbital_rank

    def update(self, *args, **kwargs):
        if not self.normal == 0:
            self.timer += 10
            if self.timer >= config.screen_width:
                self.timer = 0
            # omiting next line does cool shit
            self.rect.move_ip(self.velocity())
            x_flip, y_flip = 0, 0
            if self.velocity[0] >= 0:
                x_flip = 1
            elif self.velocity[0] < 0:
                x_flip = -1
            if self.velocity[1] >= 0:
                y_flip = 1
            elif self.velocity[1] < 0:
                y_flip = -1

            self.rect.move_ip(self.normal*y_flip*self.amp*cos_offsets[self.timer],
                              self.normal*x_flip*self.amp*sin_offsets[self.timer])
        else:
            super().update(*args, **kwargs)


class DEBUG_spinwheel(missile):
    def __init__(self, img, loc, vel, *args, **kwargs):
        super().__init__(img, loc, vel, *args, **kwargs)
        self.timer = 0
        #self.partner = partner
        #self.amp = amp
        self.x_off = cos_offsets.copy()
        self.y_off = sin_offsets.copy()
        self.normal = 1
        self.core = loc

    def update(self, *args, **kwargs):
        if not self.normal == 0:
            self.timer += 1
            if self.timer >= config.screen_width:
                self.timer = 0
            x_flip, y_flip = 0, 0
            if self.velocity[0] >= 0:
                x_flip = 1
            elif self.velocity[0] < 0:
                x_flip = -1
            if self.velocity[1] >= 0:
                y_flip = 1
            elif self.velocity[1] < 0:
                y_flip = -1

            y_vel = y_flip * (sin_offsets[self.timer] * self.timer + self.timer) * .5
            x_vel = x_flip * (cos_offsets[self.timer] * self.timer + self.timer) * .5

            self.rect.center = (x_vel+self.core[0], y_vel+self.core[1])

        else:
            super().update(*args, **kwargs)




class DEBUG_seeker_for_helix(seeker):
    def __init__(self, partner, orbital_rank, loc, direction, *args, **kwargs):
        xvel, yvel = direction[0]*7, direction[1]*7
        super().__init__(partner, 7, 20, orbital_rank, fire_book_img, loc, (xvel, yvel), *args, **kwargs, missile_name='DEBUG_seeker_for_helix')

class DEBUG_unguided_swarm(swarm, dumb_target):
    def __init__(self, **kwargs):
        super().__init__(4000, 'enemies', DEBUG_seeker_for_unguided_swarm, ice_book_img, **kwargs, spell_name="DEBUG_unguided_swarm")

class DEBUG_seeker_for_unguided_swarm(seeker):
    def __init__(self, partner, orbital_rank, loc, direction, *args, **kwargs):
        xvel, yvel = direction[0]*5, direction[1]*5
        super().__init__(partner, 7, 4, orbital_rank, fire_book_img, loc, (xvel, yvel), *args, **kwargs, missile_name="DEBUG_seeker_for_unguided_swarm")


class DEBUG_circle_me(swarm, self_target):
    def __init__(self, **kwargs):
        super().__init__(10, 'me', DEBUG_seeker_for_circle_me, light_book_img, **kwargs, spell_name="DEBUG_circle_me",
                         trigger_method=gated_trigger(reset_gate(sec/2), cap(20)))

class DEBUG_seeker_for_circle_me(seeker):
    def __init__(self, partner, orbital_rank, loc, direction, *args, **kwargs):
        xvel, yvel = direction[0], direction[1]*20
        super().__init__(partner, 1, 1, orbital_rank, bug_book_img, loc, (xvel, yvel), *args, **kwargs,
                         min_distance=30, missile_name='DEBUG_seeker_for_circle_me')

class DEBUG_strict_orbiter_for_circle_me(strict_orbit):
    def __init__(self, partner, radius, loc, direction, *args, **kwargs):
        super().__init__(partner, radius*100, fire_book_img, loc, velocity(), missile_name="DEBUG_strict_orbiter_for_circle_me")
#########################################################################################


class fireball_s(spell):
    def __init__(self, **kwargs):
        super().__init__(fireball_m, fire_book_img,
                         spell_name="fireball", **kwargs)

class fireball_m(missile):
    def __init__(self, dir, loc, **kwargs):
        # fsx = pygame.mixer.Sound("Music/MM.ogg")
        # pygame.mixer.Sound.play(fsx)
        x_vel, y_vel = 4*dir[0], 4*dir[1]
        super().__init__(fire_ball_img, loc, (x_vel, y_vel), **kwargs, missile_name='fireball')
        self.hitbox = spriteling.hitbox(self)
        self.dmg = 80
        self.elem_type = 'fire'

# still needs work, as the reset doesn't quite behave. you can cast up to the cap, release the trigger, and then cast
# additional spells up to cap, rinse and repeat
class flame_wheel_s(swarm, self_target):
    def __init__(self, **kwargs):
        super().__init__(10, 'me', flame_swirl_m, fire_book_img, spell_name='flamewheel',
                         trigger_method=gated_trigger(reset_gate(sec/2), cap(10), semi_release()),
                         **kwargs)

class flame_wheel_m(strict_orbit):
    def __init__(self, partner, radius, loc, direction, *args, **kwargs):
        super().__init__(partner, radius, small_fire_img, loc, velocity(), **kwargs, missile_name='fire_wheel',
                         max_angle=360, radius_growth=8)

class flame_swirl_m(swirl):
    def __init__(self, partner, radius, loc, direction, *args, **kwargs):
        super().__init__(.2, partner, radius, small_fire_img, loc, velocity(), **kwargs, missile_name='fire_wheel',
                         angular_speed=3)

class flamethrower_s(spell):
    def __init__(self, **kwargs):
        super(flamethrower_s, self).__init__(fireball_m, dupe(fire_book_img),
                                             spell_name='flamethrower',
                                             trigger_method=simple_multicharge_gate(40, int(sec/8), 4),
                                             **kwargs)

class fissure_s(wave_caster):
    def __init__(self, **kwargs):
        super().__init__(BIG_big_ol_rock_img, True, fissure_slab_m, rock_book_img, **kwargs, sliced=7, spell_name='fissure',
                         trigger_method=trailing_gate(reset_gate(sec/8), cap(5), cooled(2*sec), semi_release()),
                         recoil=((sec/8)+1))

class fissure_slab_m(ground_wave):
    def __init__(self, img_set, direction, loc, *args, **kwargs):
        super().__init__(img_set, 0, loc, (direction[0]*1.7, direction[1]*1.7), *args, **kwargs, missile_name='slab',
                         stage_delay=30, start_delay=50, delay_drop=3, drop_dist=-30)

class heatwave_s(wave_caster):
    def __init__(self, **kwargs):
        super().__init__(fire_ball_img, True, heatwave_m, fire_book_img, **kwargs, scaled=(7, 10), spell_name='heat_wave',
                         trigger_method=trailing_gate(reset_gate(sec/8), cap(5), cooled(2*sec), semi_release()),
                         recoil=((sec/8)+1))

class heatwave_m(air_wave):
    def __init__(self, img_set, direction, loc, *args, **kwargs):
        super().__init__(img_set, 0, loc, (direction[0]*1.7, direction[1]*1.7), *args, **kwargs, missile_name='slab',
                         stage_delay=15)

class cold_snap_s(wave_caster):
    def __init__(self, **kwargs):
        super().__init__(BIG_icicle_img, True, cold_snap_m, ice_book_img, **kwargs, sliced=6, spell_name='cold_snap',
                         trigger_method=trailing_gate(reset_gate(sec/8), cap(10), cooled(4*sec), semi_release()),
                         recoil=((sec/6)+1))

class cold_snap_m(ground_wave):
    def __init__(self, img_set, direction, loc, *args, **kwargs):
        super().__init__(img_set, 0, loc, (direction[0]*1.7, direction[1]*1.7), *args, **kwargs, missile_name='slab',
                         stage_delay=30, start_delay=50, delay_drop=3, drop_dist=-30)

class iceshard_s(spell):
    def __init__(self, **kwargs):
        super().__init__(iceshard_m, ice_book_img, **kwargs, spell_name='iceshard')


class iceshard_m(missile):
    def __init__(self, dir, loc, **kwargs):
        x_vel, y_vel = 4 * dir[0], 4 * dir[1]
        missile.__init__(self, ice_shard_img, loc, (x_vel, y_vel), **kwargs, missile_name='iceshard')
        self.hitbox = spriteling.hitbox(self)




class glacier_s(obstacle):
    pass


class icebeam_s(helix):
    def __init__(self, **kwargs):
        super(icebeam_s, self).__init__(icebeam_m, ice_book_img, spell_name='ice_beam', **kwargs,
                                        trigger_method=semi())

class icebeam_m(threelix):
    def __init__(self, partner, orbital_rank, loc, direction, *args, **kwargs):
        xvel, yvel = direction[0]*5, direction[1]*5
        super().__init__(partner, 4, orbital_rank, ice_beam_img, loc, (xvel, yvel), *args, **kwargs,
                         missile_name='ice_helix')

# might want to tweak this
class hydro_pump_s(helix):
    def __init__(self, **kwargs):
        super().__init__(hydro_pump_m, water_book_img, spell_name='hydro_pump',
                         trigger_method=simple_multicharge_gate(45, int(sec/10), 2), **kwargs)

class hydro_pump_m(threelix):
    def __init__(self, partner, orbital_rank, loc, direction, *args, **kwargs):
        xvel, yvel = direction[0]*4.2, direction[1]*4.2
        super().__init__(partner, 5, orbital_rank, water_splash_img, loc, (xvel, yvel), *args, **kwargs,
                         missile_name="hydro_splash")


class razor_leaf_s(alt_fire):
    def __init__(self, **kwargs):
        super().__init__(sharp_leaf_m, semi_release(), sharp_leaf_m, leaf_book_img, spell_name='razor_leaf', **kwargs)


## may want to expand what razor_leaf can do
class sharp_leaf_m(missile):
    def __init__(self, dir, loc, **kwargs):
        super().__init__(leaf_img, loc,  velocity(var_mag=(7, 3), dir=dir),
                         missile_name='sharp_leaf', **kwargs)
        self.curr_hp += 2


class splash_s(spell):
    def __init__(self, **kwargs):
        super().__init__(splash_m, water_book_img, **kwargs, )



class acidic_orb_s(spell):
    def __init__(self, **kwargs):
        super().__init__(acidic_orb_m, acid_book_img, **kwargs, spell_name='acid_orb')


class acidic_orb_m(missile):
    def __init__(self, dir, loc, **kwargs):
        missile.__init__(self, acid_ball_img, loc, velocity(v_mag=4, dir=dir), **kwargs, missile_name='acid_orb')
        self.hitbox = spriteling.hitbox(self)


class poison_spore_s(spell):
    def __init__(self, **kwargs):
        super().__init__(poison_spore_m, acid_book_img, trigger_method=over_heated(config.fps*3, config.fps*3/7),
                         **kwargs, spell_name='poison_spore')
        self.num_leaves = 0
        if 'num_leaves' in kwargs:
            self.num_leaves = kwargs["num_leaves"]

    def update(self, active, loc, prev, now, *args, **kwargs):
        super().update(active, loc, prev, now, *args, **kwargs)
        if 'num_leaves' in kwargs:
            self.num_leaves = kwargs["num_leaves"]

    def cast(self, direction):
        one = self.projectile(direction,  self.rect, dispersion=120, caster=self.my_caster)
        two = self.projectile(direction,  self.rect, dispersion=120, caster=self.my_caster)
        earl = self.projectile(direction, self.rect, dispersion=120, caster=self.my_caster)
        return one, two, earl

class poison_spore_m(missile):
    def __init__(self, dir, loc, **kwargs):
        v_mod = random.randint(0, 4) + 1
        super().__init__(toxic_spore_img, loc, velocity(mag=v_mod, dir=dir), **kwargs, missile_name='spore')

class burst_shard_s(spell):
    def __init__(self, **kwargs):
        super().__init__(bullet_m, metal_book_img, **kwargs, spell_name='burst_shard',
                         trigger_method=gated_trigger(reset_gate(sec/8), cap(7), semi_release()),
                         )

class chain_gun_s(spell):
    def __init__(self, **kwargs):
        super().__init__(bullet_m, metal_book_img, **kwargs, spell_name='chain_gun', trigger_method=wind_up(3, sec/3, 3))

class bullet_m(missile):
    def __init__(self, dir, loc, **kwargs):
        super().__init__(bullet_img, loc, velocity(mag=7, dir=dir), **kwargs, missile_name='bullet')


class bubble_beam_of_doom_s(helix):
    def __init__(self, **kwargs):
        super().__init__(death_bubbles_m, acid_book_img, spell_name='bubble_beam_of_doom_s', **kwargs,
                            trigger_method=wind_up(3, 3*sec/4, 4)
                         )
class death_bubbles_m(threelix):
    def __init__(self, partner, orbital_rank, loc, direction, *args, **kwargs):
        xvel, yvel = direction[0]*7, direction[1]*7
        super().__init__(partner, 3, orbital_rank, green_bubbles_img, loc, (xvel, yvel), *args, **kwargs,
                         missile_name='death_bubbles_m')


class acid_cloud_s():
    pass



# the name
class petal_storm_s(swarm, self_target, alt_fire):
    def __init__(self, **kwargs):
        super().__init__(10, 'me',
                         crazy_petals_m, gated_trigger(reset_gate(sec / 2), cap(10), semi_release()),
                         swirly_petals_m, leaf_book_img,
                         spell_name='petal_storm',
                         trigger_method=gated_trigger(reset_gate(sec / 2), cap(10), semi_release()),
                         **kwargs)

    def update(self, active, loc, prev, now, *args, **kwargs):
        self_target.update(self, active, loc, prev, now, *args, **kwargs)
        alt_fire.update(self, active, loc, prev, now, *args, **kwargs)
class swirly_petals_m(swirl):
    def __init__(self, partner, radius, loc, direction, *args, **kwargs):
        super().__init__(.2, partner, radius, leaf_img, loc, velocity(), **kwargs, missile_name='swirly_petal',
                         angular_speed=3)
class crazy_petals_m(DEBUG_spinwheel):
    def __init__(self, direction, loc, *args, **kwargs):
        x_c = random.randint(1, 3)
        if x_c == 2:
            x_c = -1
        y_c = random.randint(1, 3)
        if y_c == 2:
            y_c = -1
        super().__init__(leaf_img, loc, velocity(x_c, y_c), **kwargs, missile_name='crazy_petals',)

# swarm of bugs
class pestilence_s(swarm, self_target):
    def __init__(self, **kwargs):
        super().__init__(10, 'me', locust_m, light_book_img, **kwargs, spell_name="pestilence_s",
                         trigger_method=gated_trigger(reset_gate(sec/2), cap(20), semi_release()))
class locust_m(seeker):
    def __init__(self, partner, orbital_rank, loc, direction, *args, **kwargs):
        xvel, yvel = direction[0], direction[1]*20
        super().__init__(partner, 1, 1, orbital_rank, bug_book_img, loc, (xvel, yvel), *args, **kwargs,
                         min_distance=30, missile_name='locust_m', max_vel=3)

# not done
class light_pulse_s(spell):
    def __init__(self, **kwargs):
        super().__init__(light_pulse_m, light_book_img, **kwargs, spell_name='light_pulse')
class light_pulse_m(missile):
    def __init__(self, dir, loc):
        pass_vel = velocity(mag=4, dir=dir)
        missile.__init__(self, light_pulse_img, loc, pass_vel, missile_name='light_pulse')
        self.hitbox = spriteling.hitbox(self)


# sun lazer
class solar_beam_s(beam):
    def __init__(self, **kwargs):
        super().__init__(sun_particle_m, leaf_book_img, **kwargs,
                         trigger_method=cooled(sec*3/4), spell_name="solar_beam")
class sun_particle_m(beam_particle):
    def __init__(self, num, prev, loc, **kwargs):
        super().__init__(num, prev, sun_particle_img, loc, missile_name="sun_particle", **kwargs)


# ice lazer
class freeze_ray_s(beam):
    def __init__(self, **kwargs):
        super().__init__(ice_particle_m, ice_book_img, **kwargs,
                         trigger_method=cooled(sec*3/4))
class ice_particle_m(beam_particle):
    def __init__(self, num, prev, loc, **kwargs):
        super().__init__(num, prev, ice_shard_img, loc, missile_name="ice_ray", **kwargs)

# healing circle
class beacon_of_hope(spell):
    def __init__(self, **kwargs):
        super().__init__(healing_aura_m, light_book_img,
                         trigger_method=gated_trigger(cooled(config.fps*15), cast_per_run(3)), **kwargs,
                         spell_name='beacon_of_hope')
class healing_aura_m(aura):
    def __init__(self, dir, loc, **kwargs):
        super().__init__(False, config.fps*2, 150, loc, light_book_img, **kwargs, missile_name='healing_aura')


# flak cannon
class flak_cannon_s(remote_spell):
    def __init__(self, **kwargs):
        super().__init__(flak_burst, semi_release(), cannon_ball_m, metal_book_img, **kwargs, spell_name='flakker',
                         trigger_method=gated_trigger(reset_gate(sec / 10), cap(3), semi_release()),
                         )
cannon_ball_img = bullet_img
class cannon_ball_m(missile):
    def __init__(self, direction, loc, **kwargs):
        super().__init__(cannon_ball_img, loc, velocity(var_mag=(4.2, 1), dir=direction), **kwargs, missile_name="cannon_ball")
def flak_burst(direction, host, **kwargs):
    if direction[0] and not direction[1]:
        first_d = (direction[0], 0)
        sec_d = (direction[0], -0.5)
        thir_dir = (direction[0], .5)
    elif direction[1] and not direction[0]:
        first_d = (0, direction[1])
        sec_d = (-0.5, direction[1])
        thir_dir = (.5, direction[1])
    else:
        first_d = (direction[0], direction[1])
        sec_d = (0, direction[1])
        thir_dir = (direction[0], 0)
    first  = bullet_m(first_d,  host.rect, **kwargs, spread=8)
    second = bullet_m(sec_d,    host.rect, **kwargs, spread=8)
    third  = bullet_m(thir_dir, host.rect, **kwargs, spread=8)
    host.kill()
    return first, second, third


# the book of fire contains fire spells.
class book_of_fire(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.image = big_fire_book_img
        self.goddess_lookup_key = 'crop_top'
        self.spell_key = {0: fireball_s, 1: flame_wheel_s, 2: flamethrower_s, 3: heatwave_s}
        self.level_costs = {0: 1000, 1: 2000, 2: 3000, 3: 4000}


# the book of ice contains ice spells.
class book_of_ice(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.image = big_ice_book_img
        self.goddess_lookup_key = 'body_suit'
        self.spell_key = {0: iceshard_s, 1: icebeam_s, 2: freeze_ray_s, 3: cold_snap_s}
        self.special = glacier_s
        self.level_costs = {0: 1000, 1: 2000}


class book_of_leaves(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.img = big_leaf_book_img
        self.goddess_lookup_key = 'tattered'
        self.spell_key = {0: razor_leaf_s, 1: solar_beam_s, 2: poison_spore_s, 3: petal_storm_s}


# the book of acid contains acid spells.
class book_of_acid(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.image = big_acid_book_img
        self.goddess_lookup_key = 'tattered'
        self.spell_key = {0: acidic_orb_s, 1: poison_spore_s, 2: bubble_beam_of_doom_s, 3: pestilence_s}
        self.level_costs = {0: 1000, 1: 2000}


class book_of_light(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.image = big_light_book_img
        self.goddess_lookup_key = 'robes'
        self.spell_key = {0: light_pulse_s,  2: beacon_of_hope, 3: solar_beam_s}
        self.level_costs = {0: 1000, 1: 2000}


class book_of_waves(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.image = big_water_book_img
        self.special = None
        self.goddess_lookup_key = 'robes'
        self.spell_key = {0: splash_s, 1: cold_snap_s, 2: healing_pool_s, 3: hydro_pump_s}
        self.level_costs = {0: 1000, 1: 2000}

class book_of_wind(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.image = big_water_book_img
        self.special = None
        self.goddess_lookup_key = 'robes'
        self.spell_key = {0: razor_leaf_s, 1: gust_s, 2: tornado_s, 3: hurricane_s}
        self.level_costs = {0: 1000, 1: 2000}

class book_of_metal(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.img = big_metal_book_img
        self.goddess_lookup_key = 'tattered'
        self.spell_key = {0: burst_shard_s, 1: synthesis_s, 2: poison_spore_s, 3: chain_gun_s}

class book_of_magnets(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.img = big_magnet_book_img
        self.goddess_lookup_key = 'tattered'
        self.spell_key = {0: burst_shard_s, 1: synthesis_s, 2: poison_spore_s, 3: chain_gun_s}


class book_of_rock(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.img = big_rock_book_img
        self.goddess_lookup_key = 'tattered'
        self.spell_key = {0: burst_shard_s, 1: synthesis_s, 2: poison_spore_s, 3: solar_beam_s}

class book_of_bugs(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.img = big_bug_book_img
        self.goddess_lookup_key = 'tattered'
        self.spell_key = {0: razor_leaf_s, 1: synthesis_s, 2: poison_spore_s, 3: solar_beam_s}

class book_of_holy(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.img = big_holy_book_img
        self.goddess_lookup_key = 'tattered'
        self.spell_key = {0: razor_leaf_s, 1: synthesis_s, 2: poison_spore_s, 3: solar_beam_s}


class DEBUG_book(spell_book):
    def __init__(self, *args):
        super().__init__(len(args))
        self.image = big_DEBUG_book_img
        self.goddess_lookup_key = 'robes'
        self.spell_key = {}
        num = 0
        for each in args:
            print(num, each, " added")
            self.spell_key[num] = each
            num += 1

        print(self, "spell key: ", self.spell_key)
        self.level_costs = {0: 1000, 1: 2000}


