# dmmmmmmmmmmmmmmmmmdddmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmdddddmmmmmmmmmmmmmmmmmddmmmNN
# dNNNmyyyyyyyyyyyyyyysysyysyssssyssssysysyysyysysyssysyssysysyysysyssysssoooooossssyyyyyyysssssshmmNN
# dNNN//+////++++++++++++++++/+/++/+++++///+/+++++++/+///++++++++++++++++++++++///////++++////////hNNN
# dNNm/++:yoo+/:++:s//o:///o+:y/+:s++//++/yo:s///:o+:yo-++o+/+o++++++++++++++++++++++/////++/+++++hNNN
# hmmm/++:y++/s+oy:y/so/syso+/y+:oo+++s++/y+/so+oss+/s+++so/+so+++++++++++++++++++++++++//++++++++hNNN
# hmmm/+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++hNNN
# hmmm/-```````````````````.-----:://:....................................```````````````````````+hNNN
# hmmm:`                  `----::://.......................................`                     /hNNN
# hmmm:`                  ---:://+:```......................................`                    /hNNN
# hmmm:`                 --:-////-.`.....`...........--..-....-...--........-.``                 /hNMN
# hmmm:`                 :--:///:..-.-..`.............:-.--....-...-:..........-`                /hMMN
# hmmm:`                `:.-://+..:---.........-......-+-.--....--..-/-...-...-:-`               /hMMN
# hmmm:`                ..--:///::+//:-.-....-/--.-..-/+o:.:-....--..-/.`.--...:--               /hMMN
# hmmm:`               `-..-:/+//++s/////::::/:-.-.-/++/-:/-::....-...:/.`./..:./-.              /hMMN
# hmmm:`          .`   `-..-::o//++so//////+++//::/oo+:.``:/:/:--..-...//../..-:./-`             /hMMN
# hmmm:`         .`    ....-::o//osos//////++//+os+/:::/+/..////-----..-+/.+-.-:.:--`    `       /hMMN
# dmmm:`         ..   `/....:-+o/soos////++//+os/:..--```-.``-/++/::::::/s:o---/..`--`  ``.`     /hMMN
# dmmm:`          -...-/-...--:s+o++o////syss+++ydmdhh/.```````-/+oso++//oss/::o:- `.-..`..`     /hMMN
# dmmm:`           ```` -....:-os:.:////ohy+:ymNMMMoh-s.`````````-/o+++o+/ys///+:-    ````       /hMMN
# dmmm:`                 -...--:s``+:+//+y+`.ymsNMNNh ```````````-:+yo++ooyoo::/-.               /hMMN
# dmNm:`                 `-..---s``/:+//+o+```yyosyN: ``````````+mNdsh/::ss+/:./-`               /hMMN
# dNNm:`                  -...-:+/-/////+//.`.-+oos/ ``````````/mMNy//y.+y+//`.:.                /hMMN
# dNNm:`                  -...-+//o+:///++..```````````````````yoddh`ss:yo+:` --                 /hMMN
# dNNm:`                  :..-+///++-:://o-````````````````````sso+`.-.oy+.  .-`                 /hMMN
# mNNN:`                  :.::://++o-:-///+.```````````````-`````.-```//s/. `:`                  /hMMN
# mNNN:`                `-::--///+oo::--////`````.+..````````````````-+/+o+--`                   /hMMN
# mNNN:`            `..-.---:///++++o-:.-////`````+---....:-````````.o//:++/::--.`               /hMMN
# mNNN:`          `....---:////+++/+o---.-////````:/::::::/````````:o/+::-//:::::--`             /hMMN
# mNNN:`        `....-.-:///::++////+/.:..://o/.```.-.---```````-:+/+///:--////:--:-.            /hMMN
# mMMN:`       `...--.://+::+/////////.:..-//o///-`````````.-//s/////++//:-.:+///--:-.           /hMMN
# NMMN:`       ....:-://+-:+///////+//.-..-//+/::://:...:+///+/++//////o//--.-+///.:.-           /hMMN
# NMMN:`       ...--:////.+////////+/-.:..-//+:--:::://:s/////o/++//////o//-..:+//-:.:           /hMMN
# NMMM:`       ...-::////.////////++/.--..-//+-...------://////++++/////o/+:...///-:.-           /hMMN
# NMMM:`       ...-/-://+-///////+o/.--...://+............-//::-:ssysoo+o+/:...///:.-`           /hMMN
# NMMM:`       `...-:-:///-:+osydy-.--...-:/+.`````....````.:s-../mmmmddd//-...+/-.-`            /hMMN
# NMMM:`         `..-:::+hddddmd/.--...--:/o-..``````````..``hy...hmmmmh+/-..-:/...              /hMMN
# NMMM:`           `.-```./sdms-.--...--:/s-````.````````````dm:.-dmmho/:-.--. `.`               /hMMN
# NMMM:`          ``        .+..-....--:+hmh:```````````````:mm:.smmy//----``    ``              /hMMN
# NMMM:`        ``          ...-...--:+ydddmdy/`          .`sd+/yddm//::-```      `.             /hMMN
# NMMM:`       ``           -.:..--:+hdyhhhhhhhs:`         /hyyyyhdds/+-.` .`      :`            /hMMN
# NMMM:`      .`            ---.--:/shhhhhyyyyyyys/.      `yyyyyhhho-://:-.`       :-`           /hMMN
# NMMM:`     .`             -----::: ./syhdhhyyyyyyyo/---:yhhhhhys:`  ``...```     :`-.          /hMMN
# NMMM:`   `-.````          `----::/    .:ssyyhhhhyyhhddddmmdddddyo/-.`   `.----.` `  `.`        /hMMN
# NMMM:`  `/--.`            `./--::/:`   -.`.-:+oydddmNNmmNNNNmmmdddddhs/  `-..`        .`       /hMMN
# NMMM:```:-`           ```.....--:://:-```    .ohdmNNNNNNNNNmmNNmmdddmms   `-.`         `.`     /hMMN
# NMMM:.``         ```.........   `````      `+hddmNmmNNNNNNmNmddddddmmm-    `-.``     `---:     /hMMN
# NMMM/`      `````````........            `/hdddmNmdmNNNNNNmdmdddddmmm+      `:.``  `-.+//+`    /hMMN
# NMMMy+::::::::::::::::///////::::::::::::oyyyyyhyyyyyyhhhhyyyyyyyyyhs::::::::+//:://:::o++:::::sNMMN
# NMMMMNNNmmmNmmmNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNmmNNNNNNNNNNNmmmmNNNNNNNNNMMMMN
# NMMMMMMdsoshsosyhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmhosdNMMMMMMMMmyoodMMMMMMMMMMMMMN
# NMMMMMy:` ``` ``./dmhdmNNdhddmNNmhhdmmNNmdmNmdmddmddddmmddmNMMmddmy/.``-/ymNNmdmy:` -oNdhdmNNMMMMMMN
# NMMMMMy/-`  ..`  :/-`..-/..-`.-/:.`..-/:..:+:....:..-..-..-/so:.`..:-`   .:+/..-:-  -//.`..-/dMMMMMN
# NMMMMMMN/.  ::`  :` ``  -   `  `.`  .:.    `.   `.   `  `  `:`  `  -.  -  `.    `-  --` ` `-/mMMMMMN
# NMMMMMMN/.  ::`  :  ..  :  `:  .-`   -.  `.::  `::  `-  -` `:` `-  -.  :` `.   .:-  --     `/mMMMMMN
# NMMMMMmo-`  ``  `:  ``  -  `:  `--.  -.  `..:   .-  `-  -`  -`  `  ..  `  `.  `...  .:. `  `/mMMMMMN
# NMMMMMm+-`  .`.:+/-..-..:..-/-.--.`  --....:/-...:..-:..:-.-/-...-.::-...:+:-...-/-.--....-+hMMMMMMN
# NMMMMMMN/.`-/yhmNmdhyhhyhhhhdd+:.``.:ohdhyydmdhyhdhhhhhhhdhhddhyhhyhmdhyhmmddhyyhmdhhddhhhdNNMMMMMMN
# NMMMMMMMdsydNNNNNmmmmmmmmmmmmmdysssydmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmNNNNNNNNNMMMMMN
# NMMMMNNNNNNNNNNNmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmNNNNNNNNNNNMMN

import spriteling, pygame, math, events
from events import event_maker
from config import fps as sec
import config, random
from collections import deque

light_wave_img = pygame.image.load(      'projectiles\img_blast.png').convert_alpha()
fire_ball_img  = pygame.image.load(   'projectiles\img_fireball.png').convert_alpha()
acid_ball_img  = pygame.image.load( 'projectiles\img_poisonball.png').convert_alpha()
icy_ball_img   = pygame.image.load(    'projectiles\img_iceball.png').convert_alpha()

default_reticle =pygame.image.load('projectiles\img_crosshair.png').convert_alpha()

basic_books    = pygame.image.load('projectiles\img_basic_books.png').convert_alpha()
ice_book_img   = basic_books.subsurface(( 0,  0), (20, 20))
fire_book_img  = basic_books.subsurface(( 0, 20), (20, 20))
acid_book_img  = basic_books.subsurface(( 0, 40), (20, 20))
light_book_img = basic_books.subsurface(( 0, 60), (20, 20))
blank_book_img = basic_books.subsurface(( 0, 60), (20, 20))


bigger_books = pygame.transform.scale2x(basic_books)
bb_size = bigger_books.get_rect()
h = bb_size.height
onfr = h/4
w = bb_size.width
big_ice_book_img   = bigger_books.subsurface(( 0, onfr*0), (w, onfr))
big_fire_book_img  = bigger_books.subsurface(( 0, onfr*1), (w, onfr))
big_acid_book_img  = bigger_books.subsurface(( 0, onfr*2), (w, onfr))
big_light_book_img = bigger_books.subsurface(( 0, onfr*3), (w, onfr))
big_blank_book_img = bigger_books.subsurface(( 0, onfr*3), (w, onfr))

# need to edit this, replace it with the proper, pygame form of Copy()?
def dupe(base_surf, num=0, is_num=False, **kwargs):
    if 'size' in kwargs:
        ret = pygame.Surface(kwargs['size'])
    else:
        x, y = base_surf.get_width(), base_surf.get_height()
        ret = pygame.Surface((20, 20))
    if is_num:
        pass
    ret.blit(base_surf, (0, 0))
    return ret

# the arrangement of spells (or more generally, all attacks) goes like this: each player character gets a spell book,
# and each spell book has a particular pre-defined list of spells attached to it (one spell for each category). To
# unlock new spells, the 'add_spell' method is called from the spell book, and a string referencing the spell to be
# added is passed in. the spell_book, which already has all possible spells defined and listed in an internal
# dictionary, uses the passed in string as the key to look up which spell it should add.
# mechanically, the book just keeps track of the spells (which are unlocked and which is selected) and makes sure the
# spell's image appears in the right place (that it follows the player character around). the spell is a (potentially
# animated) sprite that follows the pc around and handles the firing of missiles/projectiles


# spell book is a handler/container class meant to hold a bunch of spells
class spell_book(spriteling.spriteling):
    def __init__(self, level=1):
        super().__init__(image=blank_book_img)
        event_maker.make_entry('log', 'spellbook', 'A new spell book has been made; this is the base constructor', 'spells', True, True,
                               'spellbook', 'spells', 'magic', 'base',
                               obj_src=spell_book, loc_src='spellbook abstract base class', inst_src=self)
        # contains an instance of/ constructor for all unlocked spells
        self.spells = []
        self.spell_key = {0: spell}
        self.level_costs = {0: 1000, 1: 2000}
        self.level = level
        self.index = 0
        self.length = 1

        # this is maintained so that spells not currently selected can still be updated (mostly fo spells that need to
        # cool down; their cooldowns don't reset upon selecting a new spell
        self.other_spells = pygame.sprite.Group()
        self.active_spell = pygame.sprite.GroupSingle()

    def get_active_spell(self):
        return (self.index, self.spells[self.index])

    def update(self, loc, *args, **kwargs):
        # the cycle and select spell are for controllers and keyboards, res. Keyboards can choose a spell based on the
        # number keys, controllers can cycle between them
        if 'cycle_spell' in kwargs:
            if kwargs['cycle_spell'] == 'next':
                self.index += 1
                if self.index >= self.length:
                    self.index = 0
            elif kwargs['cycle_spell'] == 'prev':
                self.index -= 1
                if self.index < 0:
                    self.index = self.length - 1
            self.other_spells.add(self.active_spell)
            self.active_spell.add(self.spells[self.index])
            self.other_spells.remove(self.active_spell)
            event_maker.make_entry('trace', 'changing spells', '', 'spells', False, False,
                                   'misc', 'extra', 'magic', 'spellbook',
                                   active_spell=self.spells[self.index],
                                   obj_src='spellbook', inst_src=self)
        if 'select_spell' in kwargs:
            if kwargs['select spell'] < self.length and kwargs['select_spell'] > 0:
                self.index = kwargs['select spell'] -1
            self.other_spells.add(self.active_spell)
            self.active_spell.add(self.spells[self.index])
            self.other_spells.remove(self.active_spell)
            event_maker.make_entry('trace', 'changing spells', '', 'spells', False, False,
                                   'misc', 'extra', 'magic', 'spellbook',
                                   active_spell=self.spells[self.index],
                                   obj_src='spellbook', inst_src=self)
        if 'fire' in kwargs:
            for lonely in self.active_spell:
                lonely.update(True, loc, kwargs['fire'][0], kwargs['fire'][1], kwargs['direction'], **kwargs)
        else:
            # the 'active' param must be set to false here. To tell the spell not to expect input??
            # I know that its essential to keep charged spells working
            self.active_spell.update(True, loc, 0, 0, (0, 0))

        self.other_spells.update(False, loc, 0, 0, (0, 0))

    def level_up(self):
        pass

    def pop_spells(self):
        self.length = self.level
        if self.length == 1:
            self.spells.append(self.spell_key[0]())
            self.other_spells.add(self.spells[0])
        else:
            for x in range(0, self.level):
                self.spells.append(self.spell_key[x]())
                self.other_spells.add(self.spells[x])
        self.active_spell.add(self.spells[self.index])
        self.other_spells.remove(self.active_spell)

    def pull_spells(self):
        return {'active': self.active_spell, 'other': self.other_spells}

    def pull_missiles(self):
        pass

    def draw(self, disp, draw_boxes=False):
        for each in self.active_spell:
            each.draw(disp, draw_boxes)

# each attack/spell has two components: the spell and the missile. the spell is basically just an image that follows the
# player around, while the missile is created and propelled by the spell.
# 'attack' and 'spell' are nearly interchangeable, but since 'spell' technically/internally refers to a specific object
# w/i the game files, I will shy away from using it unless I'm talking about that particular object

# ancestral class for missiles (things that fly out and hit other things)
# missiles are fired (begin moving) immediately after begin created
class missile(spriteling.spriteling):
    def __init__(self, img, loc, vel, *args, **kwargs):
        super().__init__(image=img, loc=loc)
        self.velocity = vel
        self.effects = []
        for each in args:
            self.effects.append(each)
        self.dmg = 1
        self.elem_type = 'magic'

    def update(self, *args, **kwargs):
        self.rect.move_ip(self.move())
        self.hitbox.update()

    def move(self):
        return self.velocity

    def power_up(self, multiplier, *args, **kwargs):
        self.dmg *= multiplier

    def __call__(self, victim, *args, **kwargs):
        victim.damage(self.elem_type, self.dmg)
        victim.apply(*self.effects)


class seeker(missile):
    def __init__(self, partner, accel, offset, orbital_rank, img, loc, vel, *args, **kwargs):
        super().__init__(img, loc, vel, *args, **kwargs)
        self.pair = partner
        self.accel = accel
        if orbital_rank != 0:
            sign = (orbital_rank % 2)*-1
            if self.velocity[1] != 0:
                self.velocity = (sign*offset*self.accel, self.velocity[1])
            if self.velocity[0] != 0:
                self.velocity = (self.velocity[0], sign*offset*self.accel)

    def update(self, *args, **kwargs):
        super().update(*args, **kwargs)
        if self.rect.centerx > self.pair.rect.centerx:
            self.velocity = (self.velocity[0] - self.accel, self.velocity[1])
        elif self.rect.centerx < self.pair.rect.centerx:
            self.velocity = (self.velocity[0] + self.accel, self.velocity[1])
        if self.rect.centery > self.pair.rect.centery:
            self.velocity = (self.velocity[0], self.velocity[1] - self.accel)
        elif self.rect.centery < self.pair.rect.centery:
            self.velocity = (self.velocity[0], self.velocity[1] + self.accel)

    def set_partner(self, new_partner):
        self.pair = new_partner


# partner class intended to be used with the helix missile. This provides it a moving point around which to focus itself
class epicenter():
    def __init__(self, *args):
        self.rect = pygame.rect.Rect((0, 0), (11, 11))
        self.subjects = []
        for each in args:
            self.subjects.append(each)

    def update(self, *args):
        for each in args:
            self.subjects.append(each)
        tick = 0
        total_x, total_y = 0, 0
        for each in self.subjects:
            tick += 1
            total_x += each.rect.centerx
            total_y += each.rect.centery
        self.rect.center = (total_x/tick, total_y/tick)

class trigger():
    def __call__(self, prev, now):
        return False


class semi(trigger):
    def __call__(self, prev, now):
        return now and not prev

class charged_gate(trigger):
    def __init__(self, max):
        self.charge_time = max * sec
        self.charge = 0

    def __call__(self, prev, now):
        if now and prev:
            self.charge += 1
            return False
        elif now and not prev:
            self.charge = 1
        elif prev and not now:
            return self.charge >= self.charge_time
        else:
            self.charge = 0
        return self.charge >= self.charge_time

class simple_multicharge_gate(trigger):
    def __init__(self, size, step, delay=10):
        self.thresholds = [x for x in range(step, step*size, step)]
        self.drop_rate = step
        self.charge = 0
        self.stages = 0
        self.delay = delay
        self.timer = 0

    def __call__(self, prev, now):
        if now and prev:
            self.charge += 1
            if self.charge >= self.thresholds[self.stages]:
                self.stages = min(len(self.thresholds)-1, self.stages+1)
        elif self.timer > 0:
            self.timer -=1
            return False
        elif self.stages > 0:
            self.charge = 0
            self.stages -= 1
            self.timer = self.delay
            return True
        return False

class over_heated(trigger):
    def __init__(self, max_heat, heat_per_missile):
        self.over_heated = False
        self.max_temp = max_heat
        self.buildup = heat_per_missile
        self.temp = 0

    def __call__(self, prev, now):
        if not self.over_heated and now and not prev:
            self.temp += self.buildup
            self.over_heated = self.temp > self.max_temp
            return True
        elif self.temp > 0:
            self.temp -= 1
            return False
        else:
            self.over_heated = False
        return False

class cooled(trigger):
    def __init__(self, cooldown_time):
        self.cooldown_time = cooldown_time * sec
        self.heat = 0

    def __call__(self, prev, now):
        if self.heat > 0:
            self.heat -= 1
            return False
        elif now:
            return True
        return False

class chained_trigger(trigger):
    def __init__(self, *args):
        self.gates = []
        for each in args:
            self.gates.append(each)

    def __call__(self, prev, now):
        ret = True
        for each in self.gates:
            ret = ret and each(prev, now)
        return ret

class scored_trigger(trigger):
    pass

# spells themselves don't do much, except for creating and launching missiles
# by default, spells are semi-automatic, meaning the fire key has to be released in between shots
class spell(spriteling.spriteling):
    def __init__(self, projectile, img, **kwargs):
        super().__init__(image=img)
        # this is to be initialized just before its time to fire
        self.projectile = projectile
        if 'type_name' in kwargs:
            self.type_name = kwargs['type_name']
        else:
            self.type_name = 'basic spell'
        if 'spell_name' in kwargs:
            self.spell_name = kwargs['spell_name']
        else:
            self.spell_name = "I should have a name"

        if "trigger_method" in kwargs:
            self.my_trigger = kwargs["trigger_method"]
        else:
            self.my_trigger = semi()

    def target(self, *args, **kwargs):
        pass

    # the update method controls most if not all of a spell's behavior, and is (I think) the only method of spell called
    # from outside the class. the first param dictates if the spell is active (important for all spells to know if they
    # should be trying to cast, but especially for cooldown, charged, and targeted spells. cooldoown and charged spells
    # depend on internally tracked timers that are evaluated on update, so cooldown spells need to be able to cool, and
    # charged spells need to know to reset their charge when inactive
    def update(self, active, loc, prev, now, *args, **kwargs):
        super().update(*args, **kwargs)
        if active:
            self.rect.center = loc
            if 'missile_layer' in kwargs and self.my_trigger(prev, now):
                kwargs['missile_layer'].add(self.cast(kwargs['direction']))
            else:
                pass

    # on update, an active spell attempts to cast its projectile. for most spells, this involves tracking the state of
    # the fire button and "AND"ing it to some other condition. for basic spells, this is the (negation of the) state of
    # the fire button on the previous frame (the fire button must be released in between shots).
    # the direction param is a tuple of the form (x, y) where x and y are -1, 0, or 1. these are multiplied by the
    # respective velocity multipliers to determine in which direction the spell's projectile will travel
    def cast(self, direction):
        return self.projectile(direction, self.rect.center)

    def __str__(self):
        return str(self.type_name + ' ' + self.spell_name)

# charge_up spells need to be charged by holding the fire button until they are sufficiently charged
# every frame in which the fire button is held (it determines if the button is held by checking the current and previous
# frame's data) the spell gains 1 charge.
class charge_up(spell):
    def __init__(self, threshold, *args, **kwargs):
        super().__init__(*args, type_name='charge_up', **kwargs)
        self.charge = 0
        self.charge_time = threshold * sec

    # same stuff with the update for spell base class, except now charged spells have to track if they're charging (the
    # fire button is true/held for this fram AND the previous frame)
    def update(self, active, *args, **kwargs):
        super().update(active, *args, **kwargs)
        if active:
            if self.charge < self.charge_time:
                pygame.draw.rect(self.image, (0, 200, 0), self.rect, self.charge+1)
            elif self.charge >= self.charge_time:
                pygame.draw.rect(self.image, (0, 200, 50), self.rect, 0)

    def cast(self, prev, now, direction):
        if now and not prev:
            self.charge = 1
        elif now and prev:
            self.charge += 1
        elif not now and self.charge >= self.charge_time:
            self.charge = 0
            return self.projectile(direction, self.rect.center)
        elif prev and not now:
            self.charge = 0
        return None

# multi charge spells are like the basic charge_up, except they can be charged to higher levels
class multicharge(charge_up):
    def __init__(self, thresholds, *args, **kwargs):
        self.charge_levels = thresholds
        super().__init__(thresholds[0], *args)
        event_maker.make_entry('trace', 'multicharge report', ' ', 'spells', True, True,
                               'logan', 'multicharge',
                               got_thresholds=thresholds)
        self.charges = 0
        self.firing = False
        if 'intercool' in kwargs:
            self.intercool = kwargs['intercool']
        else:
            self.intercool = 10
        self.timer = 0

    def cast(self, prev, now, direction):
        message = events.entry('trace', 'charge tracking for simple multicharge', ' ', 'spells',
                     'extra', "logan", 'low', 'multicharge',
                               charge=self.charge, charge_time=self.charge_time, max_charges=len(self.charge_levels))
        self.charge_time = self.charge_levels[self.charges]
        if self.timer > 0:
            self.timer -= 1
        if self.firing and self.charges > 0 and self.timer <= 0:
            self.timer = self.intercool
            self.charges -= 1
            message.modify(ext_desc='returning a projectile', charges=self.charges)
            event_maker.send_entry(message, True, True)
            return self.projectile(direction, self.rect.center)
        elif self.firing and self.charges <= 0:
            self.firing = False
            message.modify(ext_desc='ran out of charges')
            event_maker.send_entry(message, True, True)
            return None
        else:
            if self.charge >= self.charge_time:
                # limits the number of charges
                self.charges += 1
                event_maker.make_entry('trace', '+1 charges', "", 'spells', True, True,
                                       'multicharge',
                                       charges=self.charges)
                self.charges = min(self.charges, len(self.charge_levels)-1)
                self.charge_time = self.charge_levels[self.charges]
            if now and not prev:
                self.charge = 1
            elif now and prev:
                self.charge += 1
            elif not now and prev:
                message.modify(charge=self.charge)
                self.charge = 0
                if self.charges == 0:
                    message.modify(ext_desc="nothing has been fired; now was released when charges == 0", charges=self.charges)
                    event_maker.send_entry(message, True, True)
                    return None
                elif self.charges >= 1:
                    self.firing = True
                    message.modify(ext_desc="first projectile has been fired; now was released when charges >= 1", charges=self.charges)
                    event_maker.send_entry(message, True, True)
                    return self.projectile(direction, self.rect.center)


class simple_multicharge(multicharge):
    # size is how many charges can be held,
    # step is how long between acquiring each charge
    def __init__(self, step, size, in_sec, *args, **kwargs):
        if in_sec:
            t1 = step*config.fps
        else:
            t1 = step
        charges = [x for x in range(t1, size*t1, t1)]
        super(simple_multicharge, self).__init__(charges, *args, **kwargs)

# intended to be a basic damage/power scaling function. Merely scales as a matter of percentage, where having higher
# than the minimum translates to a direct power increase of up to double, if charge achieved == top
def basic_percentage(lvl, btm, top):
    temp = lvl-btm
    return (temp/top)+1

# has maximum and minimum charge levels;
# allows for variable levels of charge when firing/casting.
class variable_charge(charge_up):
    def __init__(self, min_charge, max_charge, *args, **kwargs):
        super().__init__(min_charge, *args, **kwargs)
        self.max_charge = max_charge *config.fps
        if 'pwr_scalar' in kwargs:
            self.pwr_scalar = kwargs['pwr_scalar']
        else:
            self.pwr_scalar = basic_percentage

    def cast(self, prev, now, direction):
        if now and not prev:
            self.charge = 1
        elif now and prev:
            self.charge += 1
        elif not now and self.charge >= self.charge_time:
            pwr_mod = self.pwr_scalar(self.charge, self.charge_time, self.max_charge)
            self.charge = 0
            ret = self.projectile(direction, self.rect.center)
            ret.power_up(pwr_mod)
            return ret
        elif prev and not now:
            self.charge = 0
        return None


class cool_down(spell):
    def __init__(self, timer, *args, **kwargs):
        super().__init__(*args, type_name='cool_down', **kwargs)
        self.heat = 0
        self.cooldown_time = timer * sec
        
    def update(self, active, *args, **kwargs):
        super(cool_down, self).update(active, *args, **kwargs)
        if self.heat > 0:
            self.heat -= 1

    def cast(self, prev, now, direction):
        if self.heat > 0:
            return None
        if now and self.heat == 0:
            self.heat = self.cooldown_time
            return self.projectile(direction, self.rect.center)


# this i gonna be weird. May want to just split it into two classes
class beam(spell):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, type_name='beam', **kwargs)
        self.own_missiles = pygame.sprite.Group()

    def update(self, active, loc, *args, **kwargs):
        shift_x, shift_y = self.rect.centerx - loc[0], self.rect.centery - loc[1]
        self.own_missiles.update()

    def cast(self, prev, now, direction):
        self.own_missiles.add(super().cast(prev, now, direction))

# a fancy, number crunchy type of spell
class automagic(spell):
    def __init__(self, acc, spread, recoil, *args, **kwargs):
        pass

class helix():
    pass

##########################
# targeted spells are fukkin nuts. I'll come back to them

# okay, so, targeted spells are made of two key components that behave very differently than normal spells. They have
# the actual spell, which contains the stuff necessary to assess and acquire targets, and the reticles, which handle the
# firing methods and applied effects.
class reticle_m(missile):
    def __init__(self, **kwargs):
        super().__init__(default_reticle, (0, 0), (0, 0))
        self.subject = None
        self.can_cast = False
        self.btns = (False, False)
        if 'subject' in kwargs:
            self.subject = kwargs['subject']

    def update(self, *args, **kwargs):
        if self.subject is not None:
            self.rect.center = self.subject.rect.center

    def set_target(self, new_target, prev, now):
        self.subject = new_target
        self.btns = (prev, now)

    def __call__(self, *args, **kwargs):
        # this will be called from room.py, but that call (and the param it passes) only tells the reticle to check if
        # it already meets the conditions for firing
        if self.can_cast and self.subject is not None:
            event_maker.make_entry('trace', 'target', "should have successfully cast a target spell", 'spells', True, True)
            return True
        else:
            return False


class charged_reticle_m(reticle_m):
    def __init__(self, charge_time, **kwargs):
        super().__init__(**kwargs)
        self.charge_time = config.fps * charge_time
        self.charge = 0

    def update(self, *args, **kwargs):
        super(charged_reticle_m, self).update()
        if self.btns[0] and self.btns[1]:
            self.charge += 1
        elif not self.btns[0] and not self.btns[1]:
            self.charge = 0
        if self.charge >= self.charge_time and self.btns[1]:
            self.charge = 0
            self.can_cast = True
        else:
            self.can_cast = False


class cooled_reticle_m(reticle_m):
    def __init__(self, cool_time, **kwargs):
        super().__init__(**kwargs)
        self.cool_time = cool_time * config.fps
        self.cool = 0

    def update(self, *args, **kwargs):
        super().update()
        if self.cool > 0:
            self.cool -= 1
        if self.cool == 0 and self.btns[1]:
            self.can_cast = True
        else:
            self.can_cast = False


class target(spell):
    def __init__(self, range, seeks, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.max_range = range
        self.chosen_target = None
        self.reticle = self.projectile()
        self.seeking = seeks

    def update(self, active, loc, prev, now, *args, **kwargs):
        if active:
            self.rect.center = loc
            if self.seeking in kwargs and 'missile_layer' in kwargs:
                # if assess_targets returns True, it means there are valid targets for this spell, and the reticle must
                # be placed in the missile layer
                if self.assess_targets(kwargs[self.seeking]):
                    event_maker.make_entry('trace', 'target', 'is assess_targets returning true?', 'spells')
                    kwargs['missile_layer'].add(self.reticle)
                # if there are no valid targets, the reticle must be removed from the missile layer
                else:
                    self.reticle.kill()
            self.reticle.set_target(self.chosen_target, prev, now)
            self.cast(prev, now, *args)
        else:
            self.reticle.kill()

    def assess_targets(self, *args):
        pass

    def cast(self, *args):
        self.reticle()


class mass_target(target):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.reticle = pygame.sprite.Group()
        self.all_targets = set()

    def assess_targets(self, *args):
        self.reticle.empty()
        for each in args:
            if self.max_range >= events.dist(self, each):
                self.reticle.add(self.projectile(subject=each))


# dumb target just targets the closest valid spriteling
class dumb_target(target):
    def assess_targets(self, targets):
        closest = 1000000000
        is_close = False
        self.chosen_target = None
        for each in targets:
            if self.max_range >= events.dist(self, each) < closest:
                self.chosen_target = each
                is_close = True
        return is_close

# this one is tricky, because it has to keep the potential targets in an ORDERED group, which is not doable with the
# basic group.
# this current version is.... not exactly what I was going for at first, but it is serviceable.
class ordered_target(target):
    def __init__(self, *args, **kwargs):
        super(ordered_target, self).__init__(*args, **kwargs)
        self.possible_targets = deque([])

    def update(self, active, loc, prev, now, *args, **kwargs):
        message = events.entry('trace', 'targets thru kwargs', '', 'spells',
                                       'simple', 'DEBUG targeting', 'ordered target')
        if active:
            message.modify(ext_desc='is active; ')
            self.rect.center = loc
            if self.seeking in kwargs:
                message.modify(ext_desc='seeking is in kwargs; ', seeking_in_kwargs=kwargs[self.seeking])
                if self.assess_targets(kwargs[self.seeking], kwargs['targ_lock']):
                    kwargs['missile_layer'].add(self.reticle)
                else:
                    self.reticle.kill()
            else:
                self.reticle.kill()
            self.reticle.set_target(self.chosen_target, prev, now)
            self.cast(prev, now, *args)
        event_maker.send_entry(message)

    def assess_targets(self, targets, cycle):
        if bool(targets):
            event_maker.make_entry('trace', 'targets found', '', 'spells', True, False,
                                   'targeting', 'extra', 'low', 'Logan',
                                   targets_found=targets)
            if len(self.possible_targets) == 0:
                for each in targets:
                    self.possible_targets.append(each)
            if self.chosen_target is None or cycle == 1:
                self.chosen_target = self.possible_targets.pop()
                self.possible_targets.appendleft(self.chosen_target)
            elif cycle == -1:
                self.chosen_target = self.possible_targets.popleft()
                self.possible_targets.append(self.chosen_target)

        else:
            self.possible_targets.clear()
            self.chosen_target = None
        return bool(self.chosen_target)


class DEBUG_target_line(ordered_target):
    def __init__(self):
        super().__init__(1000, 'enemies', dumb_heal_m, big_ice_book_img, spell_name='Debug_target_line')

    def draw(self, disp, boxes=False):
        super().draw(disp, boxes)
        if self.chosen_target is not None:
            pygame.draw.line(disp, config.green, self.rect.center, self.reticle.rect.center, 3)

class dumb_heal_s(dumb_target):
    def __init__(self):
        super().__init__(200, 'players', dumb_heal_m, light_book_img, spell_name='Dumb healing')

class dumb_heal_m(cooled_reticle_m):
    def __init__(self):
        super().__init__(1)


###############################################
class unguided_swarm(dumb_target):
    def __init__(self, secondary_proj, dist, seeks, *args, **kwargs):
        super().__init__(dist, seeks, *args, **kwargs)
        self.swarm = secondary_proj
        self.numnum = 0

    def update(self, active, loc, prev, now, *args, **kwargs):
        super().update(active, loc, prev, now, *args, **kwargs)
        if self.chosen_target is not None and self.my_trigger(prev, now):
            self.numnum +=1
            kwargs['missile_layer'].add(self.swarm(self.reticle, self.numnum, kwargs['direction']))

class guided_swarm(ordered_target):
    def __init__(self, secondary_proj, dist, seeks, *args, **kwargs):
        super().__init__(dist, seeks, *args, **kwargs)


##############################################

class DEBUG_helix(spell):
    def __init__(self):
        super().__init__(DEBUG_seeker, acid_book_img, trigger_method=simple_multicharge_gate(7, int(sec/10), 2))
        self.most_recently_fired = epicenter()

    def cast(self, direction):
        first = self.projectile(None, 1, self.rect.center, direction)
        second = self.projectile(first, 2, self.rect.center, direction)
        first.set_partner(second)
        return first, second

class DEBUG_seeker(seeker):
    def __init__(self, partner, orbital_rank, loc, direction, *args, **kwargs):
        xvel, yvel = direction[0]*3, direction[1]*3
        super().__init__(partner, 2, 3, orbital_rank, fire_book_img, loc, (xvel, yvel), *args, **kwargs)


class fireball_s(spell):
    def __init__(self):
        super().__init__(fireball_m, fire_book_img, spell_name='fireball')

class fireball_m(missile):
    def __init__(self, dir, loc):
        # fsx = pygame.mixer.Sound("Music/MM.ogg")
        # pygame.mixer.Sound.play(fsx)
        x_vel, y_vel = 4*dir[0], 4*dir[1]
        super().__init__(fire_ball_img, loc, (x_vel, y_vel))
        self.hitbox = spriteling.hitbox(self)
        self.dmg = 80
        self.elem_type = 'fire'


class charged_fireball_s(spell):
    def __init__(self):
        super().__init__(charged_fireball_m, dupe(fire_book_img),
                         spell_name="charged fireball",
                         trigger_method=charged_gate(2))


class charged_fireball_m(fireball_m):
    def __init__(self, *args, **kwargs):
        super(charged_fireball_m, self).__init__(*args, **kwargs)
        self.dmg = 100


class flamethrower_s(spell):
    def __init__(self):
        super(flamethrower_s, self).__init__(fireball_m, dupe(fire_book_img),
                                             spell_name='flamethrower',
                                             trigger_method=simple_multicharge_gate(40, int(sec/8), 4))


class heatwave_s(cool_down):
    def __init__(self):
        super().__init__(2, fireball_m, dupe(fire_book_img), spell_name='heatwave')


class iceshard_s(spell):
    def __init__(self):
        super().__init__(iceshard_m, ice_book_img)


class iceshard_m(missile):
    def __init__(self, dir, loc):
        x_vel, y_vel = 4 * dir[0], 4 * dir[1]
        missile.__init__(self, icy_ball_img, loc, (x_vel, y_vel))
        self.hitbox = spriteling.hitbox(self)


class blizzard_s():
    pass


class ice_wall_s():
    pass


class icebeam_s(spell):
    def __init__(self):
        super(icebeam_s, self).__init__(icebeam_m, ice_book_img)

class icebeam_m(seeker):
    def __init__(self, target, orbital_rank, direction, loc):
        super().__init__(target, 5, 10, orbital_rank, icy_ball_img, loc, (4 * direction[0], 4 * direction[1]))

class acidic_orb_s(spell):
    def __init__(self):
        super().__init__(acidic_orb_m, acid_book_img)


class acidic_orb_m(missile):
    def __init__(self, dir, loc):
        x_vel, y_vel = 4*dir[0], 4*dir[1]
        missile.__init__(self, acid_ball_img, loc, (x_vel, y_vel))
        self.hitbox = spriteling.hitbox(self)


class poison_spore_s():
    pass


class acid_cloud_s():
    pass


class pestilence_s():
    pass


class light_wave_s(spell):
    def __init__(self):
        super().__init__(light_wave_m, light_book_img)

class light_wave_m(missile):
    def __init__(self, dir, loc):
        x_vel, y_vel = 4*dir[0], 4*dir[1]
        missile.__init__(self, light_wave_img, loc, (x_vel, y_vel))
        self.hitbox = spriteling.hitbox(self)

class radiant_glow_s():
    pass

class solar_beam_s(beam):
    pass

# the book of fire contains fire spells.
class book_of_fire(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.image = big_fire_book_img
        self.goddess_lookup_key = 'crop_top'
        self.palette_lookup_key = ('blue', 'light blue', 'sapphire')
        self.spell_key = {0: fireball_s, 1: charged_fireball_s, 2: flamethrower_s, 3: heatwave_s}
        self.level_costs = {0: 1000, 1: 2000, 2: 3000}


# the book of ice contains ice spells.
class book_of_ice(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.image = big_ice_book_img
        self.goddess_lookup_key = 'body_suit'
        self.palette_lookup_key = ('blue', 'light blue', 'sapphire')
        self.spell_key = {0: iceshard_s, 1: blizzard_s, 2: ice_wall_s, 3: icebeam_s}
        self.level_costs = {0: 1000, 1: 2000}


# the book of acid contains acid spells.
class book_of_acid(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.image = big_acid_book_img
        self.goddess_lookup_key = 'tattered'
        self.palette_lookup_key = ('blue', 'light blue', 'sapphire')
        self.spell_key = {0: acidic_orb_s, 1: poison_spore_s, 2: acid_cloud_s, 3: pestilence_s}
        self.level_costs = {0: 1000, 1: 2000}


class book_of_light(spell_book):
    def __init__(self, level=0):
        super().__init__(level)
        self.image = big_light_book_img

        self.goddess_lookup_key = 'robes'
        self.palette_lookup_key = ('blue', 'light blue', 'sapphire')
        self.spell_key = {0: light_wave_s,  3: solar_beam_s}
        self.level_costs = {0: 1000, 1: 2000}


class DEBUG_book(spell_book):
    def __init__(self, *args):
        super().__init__(len(args))
        self.image = big_light_book_img
        self.goddess_lookup_key = 'robes'
        self.palette_lookup_key = ('blue', 'light blue', 'sapphire')
        self.spell_key = {}
        num = 0
        for each in args:
            print(num, each, " added")
            self.spell_key[num] = each
            num += 1

        print(self, "spell key: ", self.spell_key)
        self.level_costs = {0: 1000, 1: 2000}